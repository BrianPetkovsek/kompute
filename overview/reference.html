
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  <meta name="lang:clipboard.copy" content="Copy to clipboard">
  <meta name="lang:clipboard.copied" content="Copied to clipboard">
  <meta name="lang:search.language" content="en">
  <meta name="lang:search.pipeline.stopwords" content="True">
  <meta name="lang:search.pipeline.trimmer" content="True">
  <meta name="lang:search.result.none" content="No matching documents">
  <meta name="lang:search.result.one" content="1 matching document">
  <meta name="lang:search.result.other" content="# matching documents">
  <meta name="lang:search.tokenizer" content="[\s\-]+">

  
    <link href="https://fonts.gstatic.com/" rel="preconnect" crossorigin>
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono:400,500,700|Roboto:300,400,400i,700&display=fallback" rel="stylesheet">

    <style>
      body,
      input {
        font-family: "Roboto", "Helvetica Neue", Helvetica, Arial, sans-serif
      }

      code,
      kbd,
      pre {
        font-family: "Roboto Mono", "Courier New", Courier, monospace
      }
    </style>
  

  <link rel="stylesheet" href="../_static/stylesheets/application.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-palette.css"/>
  <link rel="stylesheet" href="../_static/stylesheets/application-fixes.css"/>
  
  <link rel="stylesheet" href="../_static/fonts/material-icons.css"/>
  
  <meta name="theme-color" content="#3f51b5">
  <script src="../_static/javascripts/modernizr.js"></script>
  
  <script>
      window.ga = window.ga || function () {
          (ga.q = ga.q || []).push(arguments)
      };
      ga.l = +new Date;
      ga('create', 'G-F9LD9HL8LW', 'auto');
      ga('send', 'pageview');
  </script>
  <script async src='https://www.google-analytics.com/analytics.js'></script>
  
  
    <title>Class Documentation and C++ Reference &#8212; Vulkan Kompute Documentation (Python &amp; C++)</title>
    <link rel="stylesheet" href="../_static/material.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/assets/custom.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Python Package Overview" href="python-package.html" />
    <link rel="prev" title="Extending Kompute with Custom C++ Operations" href="custom-operations.html" />
  
   

  </head>
  <body dir=ltr
        data-md-color-primary=red data-md-color-accent=light-blue>
  
  <svg class="md-svg">
    <defs data-children-count="0">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
      
    </defs>
  </svg>
  
  <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer">
  <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search">
  <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
  <a href="#overview/reference" tabindex="1" class="md-skip"> Skip to content </a>
  <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex navheader">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="../index.html" title="Vulkan Kompute Documentation (Python &amp; C++)"
           class="md-header-nav__button md-logo">
          
            &nbsp;
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          <span class="md-header-nav__topic">Vulkan Kompute Documentation (Python & C++)</span>
          <span class="md-header-nav__topic"> Class Documentation and C++ Reference </span>
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
        
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" action="../search.html" method="GET" name="search">
      <input type="text" class="md-search__input" name="q" placeholder="Search"
             autocapitalize="off" autocomplete="off" spellcheck="false"
             data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>

      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            <a href="https://github.com/EthicalML/vulkan-kompute/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Vulkan Kompute
  </div>
</a>
          </div>
        </div>
      
      
  
  <script src="../_static/javascripts/version_dropdown.js"></script>
  <script>
    var json_loc = "../"versions.json"",
        target_loc = "../../",
        text = "Versions";
    $( document ).ready( add_version_dropdown(json_loc, target_loc, text));
  </script>
  

    </div>
  </nav>
</header>

  
  <div class="md-container">
    
    
    
  <nav class="md-tabs" data-md-component="tabs">
    <div class="md-tabs__inner md-grid">
      <ul class="md-tabs__list">
          <li class="md-tabs__item"><a href="../index.html" class="md-tabs__link">Vulkan Kompute Documentation (Python & C++)</a></li>
            
            <li class="md-tabs__item"><a href="https://github.com/EthicalML/vulkan-kompute/" class="md-tabs__link">Kompute Repo</a></li>
      </ul>
    </div>
  </nav>
    <main class="md-main">
      <div class="md-main__inner md-grid" data-md-component="container">
        
          <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="../index.html" title="Vulkan Kompute Documentation (Python &amp; C++)" class="md-nav__button md-logo">
      
        <img src="../_static/" alt=" logo" width="48" height="48">
      
    </a>
    <a href="../index.html"
       title="Vulkan Kompute Documentation (Python &amp; C++)">Vulkan Kompute Documentation (Python & C++)</a>
  </label>
    <div class="md-nav__source">
      <a href="https://github.com/EthicalML/vulkan-kompute/" title="Go to repository" class="md-source" data-md-source="github">

    <div class="md-source__icon">
      <svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" viewBox="0 0 24 24" width="28" height="28">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    Vulkan Kompute
  </div>
</a>
    </div>
  
  

  
  <ul class="md-nav__list">
    <li class="md-nav__item">
    
    
      <a href="https://kompute.cc/" class="md-nav__link">Documentation Home</a>
      
    
    </li>
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">C++ Documentation:</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="advanced-examples.html" class="md-nav__link">C++ Examples</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="memory-management.html" class="md-nav__link">C++ Memory Management Principles</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="build-system.html" class="md-nav__link">C++ Build System Deep Dive</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="shaders-to-headers.html" class="md-nav__link">C++ Converting GLSL/HLSL Shaders to Cpp Headers</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="custom-operations.html" class="md-nav__link">C++ Extending Kompute with Custom Operations</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    <label class="md-nav__link md-nav__link--active" for="__toc"> C++ Class Documentation & Reference </label>
    
      <a href="#" class="md-nav__link md-nav__link--active">C++ Class Documentation & Reference</a>
      
        
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#overview-reference--page-root" class="md-nav__link">Class Documentation and C++ Reference</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#manager" class="md-nav__link">Manager</a>
        </li>
        <li class="md-nav__item"><a href="#sequence" class="md-nav__link">Sequence</a>
        </li>
        <li class="md-nav__item"><a href="#tensor" class="md-nav__link">Tensor</a>
        </li>
        <li class="md-nav__item"><a href="#algorithm" class="md-nav__link">Algorithm</a>
        </li>
        <li class="md-nav__item"><a href="#opbase" class="md-nav__link">OpBase</a>
        </li>
        <li class="md-nav__item"><a href="#opalgobase" class="md-nav__link">OpAlgoBase</a>
        </li>
        <li class="md-nav__item"><a href="#opmult" class="md-nav__link">OpMult</a>
        </li>
        <li class="md-nav__item"><a href="#optensorcreate" class="md-nav__link">OpTensorCreate</a>
        </li>
        <li class="md-nav__item"><a href="#optensorcopy" class="md-nav__link">OpTensorCopy</a>
        </li>
        <li class="md-nav__item"><a href="#optensorsynclocal" class="md-nav__link">OpTensorSyncLocal</a>
        </li>
        <li class="md-nav__item"><a href="#optensorsyncdevice" class="md-nav__link">OpTensorSyncDevice</a>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../_sources/overview/reference.rst.txt">Show Source</a> </li>

  </ul>
</nav>
      
    
    </li>
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">Python Documentation:</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="python-package.html" class="md-nav__link">Python Package Overview</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="python-examples.html" class="md-nav__link">Python Examples</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="python-reference.html" class="md-nav__link">Python Class Documentation & Reference</a>
      
    
    </li>
    <li class="md-nav__item">
    
      <span class="md-nav__link caption"><span class="caption-text">Concepts &amp; Deep Dives:</span></span>
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="ci-tests.html" class="md-nav__link">CI, Docker Images Docs & Tests</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="async-parallel.html" class="md-nav__link">Asynchronous & Parallel Operations</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="mobile-android.html" class="md-nav__link">Mobile App Integration (Android)</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="game-engine-godot.html" class="md-nav__link">Game Engine Integration (Godot Engine)</a>
      
    
    </li>
    <li class="md-nav__item">
    
    
      <a href="../genindex.html" class="md-nav__link">Code Index</a>
      
    
    </li>
  </ul>
  

</nav>
              </div>
            </div>
          </div>
          <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
            <div class="md-sidebar__scrollwrap">
              <div class="md-sidebar__inner">
                
<nav class="md-nav md-nav--secondary">
    <label class="md-nav__title" for="__toc">Contents</label>
  <ul class="md-nav__list" data-md-scrollfix="">
        <li class="md-nav__item"><a href="#overview-reference--page-root" class="md-nav__link">Class Documentation and C++ Reference</a><nav class="md-nav">
              <ul class="md-nav__list">
        <li class="md-nav__item"><a href="#manager" class="md-nav__link">Manager</a>
        </li>
        <li class="md-nav__item"><a href="#sequence" class="md-nav__link">Sequence</a>
        </li>
        <li class="md-nav__item"><a href="#tensor" class="md-nav__link">Tensor</a>
        </li>
        <li class="md-nav__item"><a href="#algorithm" class="md-nav__link">Algorithm</a>
        </li>
        <li class="md-nav__item"><a href="#opbase" class="md-nav__link">OpBase</a>
        </li>
        <li class="md-nav__item"><a href="#opalgobase" class="md-nav__link">OpAlgoBase</a>
        </li>
        <li class="md-nav__item"><a href="#opmult" class="md-nav__link">OpMult</a>
        </li>
        <li class="md-nav__item"><a href="#optensorcreate" class="md-nav__link">OpTensorCreate</a>
        </li>
        <li class="md-nav__item"><a href="#optensorcopy" class="md-nav__link">OpTensorCopy</a>
        </li>
        <li class="md-nav__item"><a href="#optensorsynclocal" class="md-nav__link">OpTensorSyncLocal</a>
        </li>
        <li class="md-nav__item"><a href="#optensorsyncdevice" class="md-nav__link">OpTensorSyncDevice</a>
        </li></ul>
            </nav>
        </li>
    
<li class="md-nav__item"><a class="md-nav__extra_link" href="../_sources/overview/reference.rst.txt">Show Source</a> </li>

<li id="searchbox" class="md-nav__item"></li>

  </ul>
</nav>
              </div>
            </div>
          </div>
        
        <div class="md-content">
          <article class="md-content__inner md-typeset" role="main">
            
  
<h1 id="overview-reference--page-root">Class Documentation and C++ Reference<a class="headerlink" href="#overview-reference--page-root" title="Permalink to this headline">¶</a></h1>
<p>This section provides a breakdown of the cpp classes and what each of their functions provide. It is partially generated and augomented from the Doxygen autodoc content. You can also go directly to the <a class="reference external" href="../doxygen/annotated.html">raw doxygen docs</a>.</p>
<p>Below is a diagram that provides insights on the relationship between Vulkan Kompute objects and Vulkan resources, which primarily encompass ownership of either CPU and/or GPU memory.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture.jpg"><img alt="../_images/kompute-vulkan-architecture.jpg" src="../_images/kompute-vulkan-architecture.jpg" style="width: 100%;"/></a>

<h2 id="manager">Manager<a class="headerlink" href="#manager" title="Permalink to this headline">¶</a></h2>
<p>The Kompute Manager provides a high level interface to simplify interaction with underlying kp::Sequences of kp::Operations.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-manager.jpg"><img alt="../_images/kompute-vulkan-architecture-manager.jpg" src="../_images/kompute-vulkan-architecture-manager.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp7ManagerE">
<span id="_CPPv3N2kp7ManagerE"></span><span id="_CPPv2N2kp7ManagerE"></span><span id="kp::Manager"></span><span class="target" id="classkp_1_1Manager"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Manager</code><a class="headerlink" href="#_CPPv4N2kp7ManagerE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base orchestrator which creates and manages device and child components </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager7ManagerEv">
<span id="_CPPv3N2kp7Manager7ManagerEv"></span><span id="_CPPv2N2kp7Manager7ManagerEv"></span><span id="kp::Manager::Manager"></span><span class="target" id="classkp_1_1Manager_1a43cc11ff353b2b0775e6a204c8395d97"></span><code class="sig-name descname">Manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager7ManagerEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base constructor and default used which creates the base resources including choosing the device 0 by default. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager7ManagerE8uint32_tRKNSt6vectorI8uint32_tEE">
<span id="_CPPv3N2kp7Manager7ManagerE8uint32_tRKNSt6vectorI8uint32_tEE"></span><span id="_CPPv2N2kp7Manager7ManagerE8uint32_tRKNSt6vectorI8uint32_tEE"></span><span id="kp::Manager::Manager__uint32_t.std::vector:uint32_t:CR"></span><span class="target" id="classkp_1_1Manager_1a7bae4bd124b9d5692b62bf48cabcf804"></span><code class="sig-name descname">Manager</code><span class="sig-paren">(</span>uint32_t <em>physicalDeviceIndex</em>, <em class="property">const</em> std::vector&lt;uint32_t&gt; &amp;<em>familyQueueIndices</em> = {}<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager7ManagerE8uint32_tRKNSt6vectorI8uint32_tEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Similar to base constructor but allows the user to provide the device they would like to create the resources on.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDeviceIndex</span></code>: The index of the physical device to use </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">familyQueueIndices</span></code>: (Optional) List of queue indices to add for explicit allocation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">totalQueues</span></code>: The total number of compute queues to create. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager7ManagerENSt10shared_ptrIN2vk8InstanceEEENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE8uint32_t">
<span id="_CPPv3N2kp7Manager7ManagerENSt10shared_ptrIN2vk8InstanceEEENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE8uint32_t"></span><span id="_CPPv2N2kp7Manager7ManagerENSt10shared_ptrIN2vk8InstanceEEENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE8uint32_t"></span><span id="kp::Manager::Manager__std::shared_ptr:vk::Instance:.std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.uint32_t"></span><span class="target" id="classkp_1_1Manager_1a81eb45116fae9ae3a34d22cf7a238b54"></span><code class="sig-name descname">Manager</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::Instance&gt; <em>instance</em>, std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, uint32_t <em>physicalDeviceIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager7ManagerENSt10shared_ptrIN2vk8InstanceEEENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p><a class="reference internal" href="#classkp_1_1Manager"><span class="std std-ref">Manager</span></a> constructor which allows your own vulkan application to integrate with the vulkan kompute use.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">instance</span></code>: Vulkan compute instance to base this application </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device to use for application </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device to use for all base resources </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDeviceIndex</span></code>: Index for vulkan physical device used </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7ManagerD0Ev">
<span id="_CPPv3N2kp7ManagerD0Ev"></span><span id="_CPPv2N2kp7ManagerD0Ev"></span><span id="kp::Manager::~Manager"></span><span class="target" id="classkp_1_1Manager_1af9b31d91851f8b7bb8d95c32a905b1ad"></span><code class="sig-name descname">~Manager</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7ManagerD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p><a class="reference internal" href="#classkp_1_1Manager"><span class="std std-ref">Manager</span></a> destructor which would ensure all owned resources are destroyed unless explicitly stated that resources should not be destroyed or freed. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager26getOrCreateManagedSequenceENSt6stringE">
<span id="_CPPv3N2kp7Manager26getOrCreateManagedSequenceENSt6stringE"></span><span id="_CPPv2N2kp7Manager26getOrCreateManagedSequenceENSt6stringE"></span><span id="kp::Manager::getOrCreateManagedSequence__ss"></span><span class="target" id="classkp_1_1Manager_1adc02b9b8c43742ff72cda3deb5440cf3"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">getOrCreateManagedSequence</code><span class="sig-paren">(</span>std::string <em>sequenceName</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager26getOrCreateManagedSequenceENSt6stringE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Get or create a managed <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> that will be contained by this manager. If the named sequence does not currently exist, it would be created and initialised.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Shared pointer to the manager owned sequence resource </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sequenceName</span></code>: The name for the named sequence to be retrieved or created </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager21createManagedSequenceENSt6stringE8uint32_t">
<span id="_CPPv3N2kp7Manager21createManagedSequenceENSt6stringE8uint32_t"></span><span id="_CPPv2N2kp7Manager21createManagedSequenceENSt6stringE8uint32_t"></span><span id="kp::Manager::createManagedSequence__ss.uint32_t"></span><span class="target" id="classkp_1_1Manager_1a23d658e7d7383ae64442dd0c078d9c98"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp8SequenceE" title="kp::Sequence">Sequence</a>&gt; <code class="sig-name descname">createManagedSequence</code><span class="sig-paren">(</span>std::string <em>sequenceName</em> = "", uint32_t <em>queueIndex</em> = 0<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager21createManagedSequenceENSt6stringE8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Create a new managed Kompute sequence so it’s available within the manager.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Weak pointer to the manager owned sequence resource </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sequenceName</span></code>: The name for the named sequence to be created, if empty then default indexed value is used </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queueIndex</span></code>: The queue to use from the available queues </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp7Manager6evalOpEvNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp7Manager6evalOpENSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp7Manager6evalOpENSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Manager_1aeb89ce2a56d09d056561f021132a5469"></span>void <code class="sig-name descname">evalOp</code><span class="sig-paren">(</span>std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, std::string <em>sequenceName</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp7Manager6evalOpEvNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs" title="kp::Manager::evalOp::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp7Manager6evalOpEvNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Function that evaluates operation against named sequence.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: The tensors to be used in the operation recorded </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sequenceName</span></code>: The name of the sequence to be retrieved or created </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TArgs</span></code>: Template parameters that will be used to initialise Operation to allow for extensible configurations on initialisation </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp7Manager13evalOpDefaultEvNSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp7Manager13evalOpDefaultENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp7Manager13evalOpDefaultENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Manager_1ae7a3f54442823198af724c97c87c3dc6"></span>void <code class="sig-name descname">evalOpDefault</code><span class="sig-paren">(</span>std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp7Manager13evalOpDefaultEvNSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="kp::Manager::evalOpDefault::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp7Manager13evalOpDefaultEvNSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Function that evaluates operation against a newly created sequence.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: The tensors to be used in the operation recorded </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TArgs</span></code>: Template parameters that will be used to initialise Operation to allow for extensible configurations on initialisation </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp7Manager11evalOpAsyncEvNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp7Manager11evalOpAsyncENSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp7Manager11evalOpAsyncENSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Manager_1a130cd4fbb2b13770aa8016aa0579755a"></span>void <code class="sig-name descname">evalOpAsync</code><span class="sig-paren">(</span>std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, std::string <em>sequenceName</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp7Manager11evalOpAsyncEvNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs" title="kp::Manager::evalOpAsync::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp7Manager11evalOpAsyncEvNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Function that evaluates operation against named sequence asynchronously.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: The tensors to be used in the operation recorded </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">sequenceName</span></code>: The name of the sequence to be retrieved or created </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">params</span></code>: Template parameters that will be used to initialise Operation to allow for extensible configurations on initialisation </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp7Manager18evalOpAsyncDefaultEvNSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp7Manager18evalOpAsyncDefaultENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp7Manager18evalOpAsyncDefaultENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Manager_1af448f96285731d412c4c54e86536d012"></span>void <code class="sig-name descname">evalOpAsyncDefault</code><span class="sig-paren">(</span>std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp7Manager18evalOpAsyncDefaultEvNSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="kp::Manager::evalOpAsyncDefault::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp7Manager18evalOpAsyncDefaultEvNSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that evaluates operation against default sequence asynchronously.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: The tensors to be used in the operation recorded </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">params</span></code>: Template parameters that will be used to initialise Operation to allow for extensible configurations on initialisation </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager11evalOpAwaitENSt6stringE8uint64_t">
<span id="_CPPv3N2kp7Manager11evalOpAwaitENSt6stringE8uint64_t"></span><span id="_CPPv2N2kp7Manager11evalOpAwaitENSt6stringE8uint64_t"></span><span id="kp::Manager::evalOpAwait__ss.uint64_t"></span><span class="target" id="classkp_1_1Manager_1a568ba498f48ea25ed0e9b319412d4b76"></span>void <code class="sig-name descname">evalOpAwait</code><span class="sig-paren">(</span>std::string <em>sequenceName</em>, uint64_t <em>waitFor</em> = UINT64_MAX<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager11evalOpAwaitENSt6stringE8uint64_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that awaits for named sequence to finish.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">sequenceName</span></code>: The name of the sequence to wait for termination </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">waitFor</span></code>: The amount of time to wait before timing out </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager18evalOpAwaitDefaultE8uint64_t">
<span id="_CPPv3N2kp7Manager18evalOpAwaitDefaultE8uint64_t"></span><span id="_CPPv2N2kp7Manager18evalOpAwaitDefaultE8uint64_t"></span><span id="kp::Manager::evalOpAwaitDefault__uint64_t"></span><span class="target" id="classkp_1_1Manager_1ab7353b924a9945093ea382b6e9780dba"></span>void <code class="sig-name descname">evalOpAwaitDefault</code><span class="sig-paren">(</span>uint64_t <em>waitFor</em> = UINT64_MAX<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager18evalOpAwaitDefaultE8uint64_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that awaits for default sequence to finish.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: The tensors to be used in the operation recorded </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">params</span></code>: Template parameters that will be used to initialise Operation to allow for extensible configurations on initialisation </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp7Manager11buildTensorERKNSt6vectorIfEEN6Tensor11TensorTypesE">
<span id="_CPPv3N2kp7Manager11buildTensorERKNSt6vectorIfEEN6Tensor11TensorTypesE"></span><span id="_CPPv2N2kp7Manager11buildTensorERKNSt6vectorIfEEN6Tensor11TensorTypesE"></span><span id="kp::Manager::buildTensor__std::vector:float:CR.Tensor::TensorTypes"></span><span class="target" id="classkp_1_1Manager_1a13e7b747a19ca43f32024f6b4347b642"></span>std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt; <code class="sig-name descname">buildTensor</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;float&gt; &amp;<em>data</em>, <a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>::<a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a> <em>tensorType</em> = <a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>::<a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a>::<a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypes7eDeviceE" title="kp::Tensor::TensorTypes::eDevice">eDevice</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp7Manager11buildTensorERKNSt6vectorIfEEN6Tensor11TensorTypesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Function that simplifies the common workflow of tensor creation and initialization. It will take the constructor parameters for a <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> and will will us it to create a new <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> and then create it using the OpCreateTensor command.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Initialized <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> with memory Syncd to GPU device </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: The data to initialize the tensor with </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensorType</span></code>: The type of tensor to initialize </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>


<h2 id="sequence">Sequence<a class="headerlink" href="#sequence" title="Permalink to this headline">¶</a></h2>
<p>The Kompute Sequence consists of batches of kp::Operations, which are executed on a respective GPU queue. The execution of sequences can be synchronous or asynchronous, and it can be coordinated through its respective vk::Fence.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-sequence.jpg"><img alt="../_images/kompute-vulkan-architecture-sequence.jpg" src="../_images/kompute-vulkan-architecture-sequence.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp8SequenceE">
<span id="_CPPv3N2kp8SequenceE"></span><span id="_CPPv2N2kp8SequenceE"></span><span id="kp::Sequence"></span><span class="target" id="classkp_1_1Sequence"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Sequence</code><a class="headerlink" href="#_CPPv4N2kp8SequenceE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Container of operations that can be sent to GPU as batch </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence8SequenceEv">
<span id="_CPPv3N2kp8Sequence8SequenceEv"></span><span id="_CPPv2N2kp8Sequence8SequenceEv"></span><span id="kp::Sequence::Sequence"></span><span class="target" id="classkp_1_1Sequence_1a7086ddbc33ffb5c99cfc83cfa926f65e"></span><code class="sig-name descname">Sequence</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence8SequenceEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base constructor for <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a>. Should not be used unless explicit intended. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence8SequenceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk5QueueEEE8uint32_t">
<span id="_CPPv3N2kp8Sequence8SequenceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk5QueueEEE8uint32_t"></span><span id="_CPPv2N2kp8Sequence8SequenceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk5QueueEEE8uint32_t"></span><span id="kp::Sequence::Sequence__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::Queue:.uint32_t"></span><span class="target" id="classkp_1_1Sequence_1a83518e6c7f249680a9a0a9e7d5270b9a"></span><code class="sig-name descname">Sequence</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::Queue&gt; <em>computeQueue</em>, uint32_t <em>queueIndex</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence8SequenceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk5QueueEEE8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Main constructor for sequence which requires core vulkan components to generate all dependent resources.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">computeQueue</span></code>: Vulkan compute queue </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">queueIndex</span></code>: Vulkan compute queue index in device </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8SequenceD0Ev">
<span id="_CPPv3N2kp8SequenceD0Ev"></span><span id="_CPPv2N2kp8SequenceD0Ev"></span><span id="kp::Sequence::~Sequence"></span><span class="target" id="classkp_1_1Sequence_1a657bf520b64ddbd42e12095c5241ef52"></span><code class="sig-name descname">~Sequence</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8SequenceD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destructor for sequence which is responsible for cleaning all subsequent owned operations. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence4initEv">
<span id="_CPPv3N2kp8Sequence4initEv"></span><span id="_CPPv2N2kp8Sequence4initEv"></span><span id="kp::Sequence::init"></span><span class="target" id="classkp_1_1Sequence_1a437ff4b49b8ce0e4fd9f80ea2d1d3593"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence4initEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Initialises sequence including the creation of the command pool and the command buffer. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence5beginEv">
<span id="_CPPv3N2kp8Sequence5beginEv"></span><span id="_CPPv2N2kp8Sequence5beginEv"></span><span id="kp::Sequence::begin"></span><span class="target" id="classkp_1_1Sequence_1a9b4922affdae332381e14c7c555bdfc4"></span>bool <code class="sig-name descname">begin</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence5beginEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Begins recording commands for commands to be submitted into the command buffer.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating whether execution was successful. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence3endEv">
<span id="_CPPv3N2kp8Sequence3endEv"></span><span id="_CPPv2N2kp8Sequence3endEv"></span><span id="kp::Sequence::end"></span><span class="target" id="classkp_1_1Sequence_1ac51befb176acd2064d3e85133bf66ada"></span>bool <code class="sig-name descname">end</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence3endEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Ends the recording and stops recording commands when the record command is sent.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating whether execution was successful. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence4evalEv">
<span id="_CPPv3N2kp8Sequence4evalEv"></span><span id="_CPPv2N2kp8Sequence4evalEv"></span><span id="kp::Sequence::eval"></span><span class="target" id="classkp_1_1Sequence_1aa0b36564769ba25a43a38e14a2d510dc"></span>bool <code class="sig-name descname">eval</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence4evalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval sends all the recorded and stored operations in the vector of operations into the gpu as a submit job with a barrier.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating whether execution was successful. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence9evalAsyncEv">
<span id="_CPPv3N2kp8Sequence9evalAsyncEv"></span><span id="_CPPv2N2kp8Sequence9evalAsyncEv"></span><span id="kp::Sequence::evalAsync"></span><span class="target" id="classkp_1_1Sequence_1a682cba00ed524212503f0b977f98fc56"></span>bool <code class="sig-name descname">evalAsync</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence9evalAsyncEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval Async sends all the recorded and stored operations in the vector of operations into the gpu as a submit job with a barrier. EvalAwait() must be called after to ensure the sequence is terminated correctly.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating whether execution was successful. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence9evalAwaitE8uint64_t">
<span id="_CPPv3N2kp8Sequence9evalAwaitE8uint64_t"></span><span id="_CPPv2N2kp8Sequence9evalAwaitE8uint64_t"></span><span id="kp::Sequence::evalAwait__uint64_t"></span><span class="target" id="classkp_1_1Sequence_1a9cd3819206f56734876873656085c824"></span>bool <code class="sig-name descname">evalAwait</code><span class="sig-paren">(</span>uint64_t <em>waitFor</em> = UINT64_MAX<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence9evalAwaitE8uint64_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Eval Await waits for the fence to finish processing and then once it finishes, it runs the postEval of all operations.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating whether execution was successful. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">waitFor</span></code>: Number of milliseconds to wait before timing out. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence11isRecordingEv">
<span id="_CPPv3N2kp8Sequence11isRecordingEv"></span><span id="_CPPv2N2kp8Sequence11isRecordingEv"></span><span id="kp::Sequence::isRecording"></span><span class="target" id="classkp_1_1Sequence_1ac6400fc9c0fb879e1131157fef8b2e85"></span>bool <code class="sig-name descname">isRecording</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence11isRecordingEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns true if the sequence is currently in recording activated.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating if recording ongoing. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence9isRunningEv">
<span id="_CPPv3N2kp8Sequence9isRunningEv"></span><span id="_CPPv2N2kp8Sequence9isRunningEv"></span><span id="kp::Sequence::isRunning"></span><span class="target" id="classkp_1_1Sequence_1a1a783a310d7373588277df4ba6dc30da"></span>bool <code class="sig-name descname">isRunning</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence9isRunningEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns true if the sequence is currently running - mostly used for async workloads.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating if currently running. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence6isInitEv">
<span id="_CPPv3N2kp8Sequence6isInitEv"></span><span id="_CPPv2N2kp8Sequence6isInitEv"></span><span id="kp::Sequence::isInit"></span><span class="target" id="classkp_1_1Sequence_1a84ff30d6164cc730bd554dcdfd423f74"></span>bool <code class="sig-name descname">isInit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence6isInitEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns true if the sequence has been successfully initialised.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Boolean stating if sequence has been initialised. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp8Sequence29freeMemoryDestroyGPUResourcesEv">
<span id="_CPPv3N2kp8Sequence29freeMemoryDestroyGPUResourcesEv"></span><span id="_CPPv2N2kp8Sequence29freeMemoryDestroyGPUResourcesEv"></span><span id="kp::Sequence::freeMemoryDestroyGPUResources"></span><span class="target" id="classkp_1_1Sequence_1a6c29f6b498c362b97f37185ffd9c0fc2"></span>void <code class="sig-name descname">freeMemoryDestroyGPUResources</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp8Sequence29freeMemoryDestroyGPUResourcesEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destroys and frees the GPU resources which include the buffer and memory and sets the sequence as init=False. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4I0DpEN2kp8Sequence6recordEbNSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs">
<span id="_CPPv3I0DpEN2kp8Sequence6recordENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span><span id="_CPPv2I0DpEN2kp8Sequence6recordENSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs"></span>template&lt;typename <code class="sig-name descname">T</code>, typename ...<code class="sig-name descname">TArgs</code>&gt;<br/><span class="target" id="classkp_1_1Sequence_1a3cf05ff800f9bbb267be2367f554c2f4"></span>bool <code class="sig-name descname">record</code><span class="sig-paren">(</span>std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, <a class="reference internal" href="#_CPPv4I0DpEN2kp8Sequence6recordEbNSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="kp::Sequence::record::TArgs">TArgs</a>&amp;&amp;... <em>params</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4I0DpEN2kp8Sequence6recordEbNSt6vectorINSt10shared_ptrI6TensorEEEEDpRR5TArgs" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Record function for operation to be added to the GPU queue in batch. This template requires classes to be derived from the <a class="reference internal" href="#classkp_1_1OpBase"><span class="std std-ref">OpBase</span></a> class. This function also requires the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> to be recording, otherwise it will not be able to add the operation.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Vector of tensors to use for the operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">TArgs</span></code>: Template parameters that are used to initialise operation which allows for extensible configurations on initialisation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>


<h2 id="tensor">Tensor<a class="headerlink" href="#tensor" title="Permalink to this headline">¶</a></h2>
<p>The kp::Tensor is the atomic unit in Kompute, and it is used primarily for handling Host and GPU Device data.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-tensor.jpg"><img alt="../_images/kompute-vulkan-architecture-tensor.jpg" src="../_images/kompute-vulkan-architecture-tensor.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp6TensorE">
<span id="_CPPv3N2kp6TensorE"></span><span id="_CPPv2N2kp6TensorE"></span><span id="kp::Tensor"></span><span class="target" id="classkp_1_1Tensor"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Tensor</code><a class="headerlink" href="#_CPPv4N2kp6TensorE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Structured data used in GPU operations.</p>
<p>Tensors are the base building block in Kompute to perform operations across GPUs. Each tensor would have a respective Vulkan memory and buffer, which would be used to store their respective data. The tensors can be used for GPU data storage or transfer. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Types</p>
<dl class="cpp enum">
<dt id="_CPPv4N2kp6Tensor11TensorTypesE">
<span id="_CPPv3N2kp6Tensor11TensorTypesE"></span><span id="_CPPv2N2kp6Tensor11TensorTypesE"></span><span class="target" id="classkp_1_1Tensor_1a1b2af1c0e8dc0f154e11780e7103beb4"></span><em class="property">enum </em><code class="sig-name descname">TensorTypes</code><a class="headerlink" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Type for tensors created: Device allows memory to be transferred from staging buffers. Staging are host memory visible. Storage are device visible but are not set up to transfer or receive data (only for shader storage). </p>
<p><em>Values:</em></p>
<dl class="cpp enumerator">
<dt id="_CPPv4N2kp6Tensor11TensorTypes7eDeviceE">
<span id="_CPPv3N2kp6Tensor11TensorTypes7eDeviceE"></span><span id="_CPPv2N2kp6Tensor11TensorTypes7eDeviceE"></span><span class="target" id="classkp_1_1Tensor_1a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f"></span><em class="property">enumerator </em><code class="sig-name descname">eDevice</code> = 0<a class="headerlink" href="#_CPPv4N2kp6Tensor11TensorTypes7eDeviceE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Type is device memory, source and destination. </p>
</dd></dl>
<dl class="cpp enumerator">
<dt id="_CPPv4N2kp6Tensor11TensorTypes8eStagingE">
<span id="_CPPv3N2kp6Tensor11TensorTypes8eStagingE"></span><span id="_CPPv2N2kp6Tensor11TensorTypes8eStagingE"></span><span class="target" id="classkp_1_1Tensor_1a1b2af1c0e8dc0f154e11780e7103beb4ab288dd012e30ff97c0236b12e3c2c6e5"></span><em class="property">enumerator </em><code class="sig-name descname">eStaging</code> = 1<a class="headerlink" href="#_CPPv4N2kp6Tensor11TensorTypes8eStagingE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Type is host memory, source and destination. </p>
</dd></dl>
<dl class="cpp enumerator">
<dt id="_CPPv4N2kp6Tensor11TensorTypes8eStorageE">
<span id="_CPPv3N2kp6Tensor11TensorTypes8eStorageE"></span><span id="_CPPv2N2kp6Tensor11TensorTypes8eStorageE"></span><span class="target" id="classkp_1_1Tensor_1a1b2af1c0e8dc0f154e11780e7103beb4ae1a7e733531f08074becd467959f0521"></span><em class="property">enumerator </em><code class="sig-name descname">eStorage</code> = 2<a class="headerlink" href="#_CPPv4N2kp6Tensor11TensorTypes8eStorageE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Type is Device memory (only) </p>
</dd></dl>
</dd></dl>
</div>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor6TensorEv">
<span id="_CPPv3N2kp6Tensor6TensorEv"></span><span id="_CPPv2N2kp6Tensor6TensorEv"></span><span id="kp::Tensor::Tensor"></span><span class="target" id="classkp_1_1Tensor_1aee6c5bb44b1c58d67c33c86efdc24acd"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor6TensorEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base constructor, should not be used unless explicitly intended. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor6TensorERKNSt6vectorIfEE11TensorTypes">
<span id="_CPPv3N2kp6Tensor6TensorERKNSt6vectorIfEE11TensorTypes"></span><span id="_CPPv2N2kp6Tensor6TensorERKNSt6vectorIfEE11TensorTypes"></span><span id="kp::Tensor::Tensor__std::vector:float:CR.TensorTypes"></span><span class="target" id="classkp_1_1Tensor_1a64277a710229f5407f3975f9164da26a"></span><code class="sig-name descname">Tensor</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;float&gt; &amp;<em>data</em>, <a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a> <em>tensorType</em> = <a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a>::<a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypes7eDeviceE" title="kp::Tensor::TensorTypes::eDevice">eDevice</a><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor6TensorERKNSt6vectorIfEE11TensorTypes" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with data provided which would be used to create the respective vulkan buffer and memory.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">data</span></code>: Vector of data that will be used by the tensor </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensorType</span></code>: Type for the tensor which is of type TensorTypes </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6TensorD0Ev">
<span id="_CPPv3N2kp6TensorD0Ev"></span><span id="_CPPv2N2kp6TensorD0Ev"></span><span id="kp::Tensor::~Tensor"></span><span class="target" id="classkp_1_1Tensor_1a38e886e69103a956b994790f320a254e"></span><code class="sig-name descname">~Tensor</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6TensorD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destructor which is in charge of freeing vulkan resources unless they have been provided externally. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor4initENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE">
<span id="_CPPv3N2kp6Tensor4initENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE"></span><span id="_CPPv2N2kp6Tensor4initENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE"></span><span id="kp::Tensor::init__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:"></span><span class="target" id="classkp_1_1Tensor_1abbb298bd2aea2bd9cea4eb9a741d2de3"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor4initENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Initialiser which calls the initialisation for all the respective tensors as well as creates the respective staging tensors. The staging tensors would only be created for the tensors of type TensorType::eDevice as otherwise there is no need to copy from host memory. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor29freeMemoryDestroyGPUResourcesEv">
<span id="_CPPv3N2kp6Tensor29freeMemoryDestroyGPUResourcesEv"></span><span id="_CPPv2N2kp6Tensor29freeMemoryDestroyGPUResourcesEv"></span><span id="kp::Tensor::freeMemoryDestroyGPUResources"></span><span class="target" id="classkp_1_1Tensor_1afdfc816a4f040ad43e36534c6fbc69a2"></span>void <code class="sig-name descname">freeMemoryDestroyGPUResources</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor29freeMemoryDestroyGPUResourcesEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destroys and frees the GPU resources which include the buffer and memory. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor4dataEv">
<span id="_CPPv3N2kp6Tensor4dataEv"></span><span id="_CPPv2N2kp6Tensor4dataEv"></span><span id="kp::Tensor::data"></span><span class="target" id="classkp_1_1Tensor_1a858f9a010a112983244cdf16ea0e5308"></span>std::vector&lt;float&gt; &amp;<code class="sig-name descname">data</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor4dataEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns the vector of data currently contained by the <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a>. It is important to ensure that there is no out-of-sync data with the GPU memory.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Reference to vector of elements representing the data in the tensor. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6TensorixEi">
<span id="_CPPv3N2kp6TensorixEi"></span><span id="_CPPv2N2kp6TensorixEi"></span><span id="kp::Tensor::subscript-operator__i"></span><span class="target" id="classkp_1_1Tensor_1a64ff1ca98d5380cc3916e13b20f7a509"></span>float &amp;<code class="sig-name descname">operator[]</code><span class="sig-paren">(</span>int <em>index</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6TensorixEi" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Overrides the subscript operator to expose the underlying data’s subscript operator which in this case would be its underlying vector’s.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Returns the element in the position requested. </p>
</dd>
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">i</span></code>: The index where the element will be returned from. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor4sizeEv">
<span id="_CPPv3N2kp6Tensor4sizeEv"></span><span id="_CPPv2N2kp6Tensor4sizeEv"></span><span id="kp::Tensor::size"></span><span class="target" id="classkp_1_1Tensor_1a1fb937df6cc482c1f37c74d8fab0f9a9"></span>uint32_t <code class="sig-name descname">size</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor4sizeEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns the size/magnitude of the <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a>, which will be the total number of elements across all dimensions</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Unsigned integer representing the total number of elements </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor5shapeEv">
<span id="_CPPv3N2kp6Tensor5shapeEv"></span><span id="_CPPv2N2kp6Tensor5shapeEv"></span><span id="kp::Tensor::shape"></span><span class="target" id="classkp_1_1Tensor_1a70a95b98a2558fbc80458c22ca9e043c"></span>std::array&lt;uint32_t, KP_MAX_DIM_SIZE&gt; <code class="sig-name descname">shape</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor5shapeEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns the shape of the tensor, which includes the number of dimensions and the size per dimension.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Array containing the sizes for each dimension. Zero means respective dimension is not active. </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor10tensorTypeEv">
<span id="_CPPv3N2kp6Tensor10tensorTypeEv"></span><span id="_CPPv2N2kp6Tensor10tensorTypeEv"></span><span id="kp::Tensor::tensorType"></span><span class="target" id="classkp_1_1Tensor_1a59452f1c62fd738536bb0a6cbf8d896b"></span><a class="reference internal" href="#_CPPv4N2kp6Tensor11TensorTypesE" title="kp::Tensor::TensorTypes">TensorTypes</a> <code class="sig-name descname">tensorType</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor10tensorTypeEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Retrieve the tensor type of the <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a></p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p><a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> type of tensor </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor6isInitEv">
<span id="_CPPv3N2kp6Tensor6isInitEv"></span><span id="_CPPv2N2kp6Tensor6isInitEv"></span><span id="kp::Tensor::isInit"></span><span class="target" id="classkp_1_1Tensor_1af2ae7f0b57fd8e57570ab63962a97f36"></span>bool <code class="sig-name descname">isInit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor6isInitEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Returns true if the tensor initialisation function has been carried out successful, which would mean that the buffer and memory will have been provisioned. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor7setDataERKNSt6vectorIfEE">
<span id="_CPPv3N2kp6Tensor7setDataERKNSt6vectorIfEE"></span><span id="_CPPv2N2kp6Tensor7setDataERKNSt6vectorIfEE"></span><span id="kp::Tensor::setData__std::vector:float:CR"></span><span class="target" id="classkp_1_1Tensor_1a3618a3e5a86cfaad31820f9910525424"></span>void <code class="sig-name descname">setData</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;float&gt; &amp;<em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor7setDataERKNSt6vectorIfEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Sets / resets the vector data of the tensor. This function does not perform any copies into GPU memory and is only performed on the host. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor14recordCopyFromENSt10shared_ptrIN2vk13CommandBufferEEENSt10shared_ptrI6TensorEEb">
<span id="_CPPv3N2kp6Tensor14recordCopyFromENSt10shared_ptrIN2vk13CommandBufferEEENSt10shared_ptrI6TensorEEb"></span><span id="_CPPv2N2kp6Tensor14recordCopyFromENSt10shared_ptrIN2vk13CommandBufferEEENSt10shared_ptrI6TensorEEb"></span><span id="kp::Tensor::recordCopyFrom__std::shared_ptr:vk::CommandBuffer:.std::shared_ptr:Tensor:.b"></span><span class="target" id="classkp_1_1Tensor_1a1b54d0040e09e918620fcce44651fb24"></span>void <code class="sig-name descname">recordCopyFrom</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt; <em>copyFromTensor</em>, bool <em>createBarrier</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor14recordCopyFromENSt10shared_ptrIN2vk13CommandBufferEEENSt10shared_ptrI6TensorEEb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records a copy from the memory of the tensor provided to the current thensor. This is intended to pass memory into a processing, to perform a staging buffer transfer, or to gather output (between others).</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record the commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">copyFromTensor</span></code>: <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> to copy the data from </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">createBarrier</span></code>: Whether to create a barrier that ensures the data is copied before further operations. Default is true. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor25recordBufferMemoryBarrierENSt10shared_ptrIN2vk13CommandBufferEEEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE">
<span id="_CPPv3N2kp6Tensor25recordBufferMemoryBarrierENSt10shared_ptrIN2vk13CommandBufferEEEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE"></span><span id="_CPPv2N2kp6Tensor25recordBufferMemoryBarrierENSt10shared_ptrIN2vk13CommandBufferEEEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE"></span><span id="kp::Tensor::recordBufferMemoryBarrier__std::shared_ptr:vk::CommandBuffer:.vk::AccessFlagBits.vk::AccessFlagBits.vk::PipelineStageFlagBits.vk::PipelineStageFlagBits"></span><span class="target" id="classkp_1_1Tensor_1a2b3c387940770f7d6de891ece13190bd"></span>void <code class="sig-name descname">recordBufferMemoryBarrier</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, vk::AccessFlagBits <em>srcAccessMask</em>, vk::AccessFlagBits <em>dstAccessMask</em>, vk::PipelineStageFlagBits <em>srcStageMask</em>, vk::PipelineStageFlagBits <em>dstStageMask</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor25recordBufferMemoryBarrierENSt10shared_ptrIN2vk13CommandBufferEEEN2vk14AccessFlagBitsEN2vk14AccessFlagBitsEN2vk21PipelineStageFlagBitsEN2vk21PipelineStageFlagBitsE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records the buffer memory barrier into the command buffer which ensures that relevant data transfers are carried out correctly.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record the commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">srcAccessMask</span></code>: Access flags for source access mask </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dstAccessMask</span></code>: Access flags for destination access mask </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">scrStageMask</span></code>: Pipeline stage flags for source stage mask </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">dstStageMask</span></code>: Pipeline stage flags for destination stage mask </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor29constructDescriptorBufferInfoEv">
<span id="_CPPv3N2kp6Tensor29constructDescriptorBufferInfoEv"></span><span id="_CPPv2N2kp6Tensor29constructDescriptorBufferInfoEv"></span><span id="kp::Tensor::constructDescriptorBufferInfo"></span><span class="target" id="classkp_1_1Tensor_1a805e6050a935763488116e071c0ce461"></span>vk::DescriptorBufferInfo <code class="sig-name descname">constructDescriptorBufferInfo</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor29constructDescriptorBufferInfoEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Constructs a vulkan descriptor buffer info which can be used to specify and reference the underlying buffer component of the tensor without exposing it.</p>
<p><dl class="simple">
<dt><strong>Return</strong></dt><dd><p>Descriptor buffer info with own buffer </p>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor21mapDataFromHostMemoryEv">
<span id="_CPPv3N2kp6Tensor21mapDataFromHostMemoryEv"></span><span id="_CPPv2N2kp6Tensor21mapDataFromHostMemoryEv"></span><span id="kp::Tensor::mapDataFromHostMemory"></span><span class="target" id="classkp_1_1Tensor_1ae8e16f48058f17d55d313727c9ceaa46"></span>void <code class="sig-name descname">mapDataFromHostMemory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor21mapDataFromHostMemoryEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Maps data from the Host Visible GPU memory into the data vector. It requires the <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> to be of staging type for it to work. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6Tensor21mapDataIntoHostMemoryEv">
<span id="_CPPv3N2kp6Tensor21mapDataIntoHostMemoryEv"></span><span id="_CPPv2N2kp6Tensor21mapDataIntoHostMemoryEv"></span><span id="kp::Tensor::mapDataIntoHostMemory"></span><span class="target" id="classkp_1_1Tensor_1aeeeb1b7d8ed4681565f17e44c98fb704"></span>void <code class="sig-name descname">mapDataIntoHostMemory</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6Tensor21mapDataIntoHostMemoryEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Maps data from the data vector into the Host Visible GPU memory. It requires the tensor to be of staging type for it to work. </p>
</dd></dl>
</div>
</dd></dl>


<h2 id="algorithm">Algorithm<a class="headerlink" href="#algorithm" title="Permalink to this headline">¶</a></h2>
<p>The kp::Algorithm consists primarily of the components required for shader code execution, including the relevant vk::DescriptorSet relatedresources as well as vk::Pipeline and all the relevant Vulkan resources as outlined in the architectural diagram.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-algorithm.jpg"><img alt="../_images/kompute-vulkan-architecture-algorithm.jpg" src="../_images/kompute-vulkan-architecture-algorithm.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp9AlgorithmE">
<span id="_CPPv3N2kp9AlgorithmE"></span><span id="_CPPv2N2kp9AlgorithmE"></span><span id="kp::Algorithm"></span><span class="target" id="classkp_1_1Algorithm"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">Algorithm</code><a class="headerlink" href="#_CPPv4N2kp9AlgorithmE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Abstraction for compute shaders that are run on top of tensors grouped via ParameterGroups (which group descriptorsets) </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm9AlgorithmEv">
<span id="_CPPv3N2kp9Algorithm9AlgorithmEv"></span><span id="_CPPv2N2kp9Algorithm9AlgorithmEv"></span><span id="kp::Algorithm::Algorithm"></span><span class="target" id="classkp_1_1Algorithm_1abca36359b946dc1102890d34b6fa562b"></span><code class="sig-name descname">Algorithm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm9AlgorithmEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base constructor for <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a>. Should not be used unless explicit intended. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEE">
<span id="_CPPv3N2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEE"></span><span id="_CPPv2N2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEE"></span><span id="kp::Algorithm::Algorithm__std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:"></span><span class="target" id="classkp_1_1Algorithm_1a71175003231f8a716df9146d70a70303"></span><code class="sig-name descname">Algorithm</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm9AlgorithmENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor for <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a></p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: The Vulkan device to use for creating resources </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: The vulkan command buffer to bind the pipeline and shaders </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm4initERKNSt6vectorIcEENSt6vectorINSt10shared_ptrI6TensorEEEE">
<span id="_CPPv3N2kp9Algorithm4initERKNSt6vectorIcEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="_CPPv2N2kp9Algorithm4initERKNSt6vectorIcEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="kp::Algorithm::init__std::vector:c:CR.std::vector:std::shared_ptr:Tensor::"></span><span class="target" id="classkp_1_1Algorithm_1ae54d2ab78d3236964d4281635368d8ef"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span><em class="property">const</em> std::vector&lt;char&gt; &amp;<em>shaderFileData</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensorParams</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm4initERKNSt6vectorIcEENSt6vectorINSt10shared_ptrI6TensorEEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Initialiser for the shader data provided to the algorithm as well as tensor parameters that will be used in shader.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">shaderFileData</span></code>: The bytes in spir-v format of the shader  The Tensors to be used in the <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> / shader for processing </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9AlgorithmD0Ev">
<span id="_CPPv3N2kp9AlgorithmD0Ev"></span><span id="_CPPv2N2kp9AlgorithmD0Ev"></span><span id="kp::Algorithm::~Algorithm"></span><span class="target" id="classkp_1_1Algorithm_1a8bb732b02135afeec7e80e7a2c5d3ce7"></span><code class="sig-name descname">~Algorithm</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9AlgorithmD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Destructor for <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> which is responsible for freeing and desroying respective pipelines and owned parameter groups. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp9Algorithm14recordDispatchE8uint32_t8uint32_t8uint32_t">
<span id="_CPPv3N2kp9Algorithm14recordDispatchE8uint32_t8uint32_t8uint32_t"></span><span id="_CPPv2N2kp9Algorithm14recordDispatchE8uint32_t8uint32_t8uint32_t"></span><span id="kp::Algorithm::recordDispatch__uint32_t.uint32_t.uint32_t"></span><span class="target" id="classkp_1_1Algorithm_1ad4bd57e0e03ccdc113c7c38b181ccbf6"></span>void <code class="sig-name descname">recordDispatch</code><span class="sig-paren">(</span>uint32_t <em>x</em> = 1, uint32_t <em>y</em> = 1, uint32_t <em>z</em> = 1<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp9Algorithm14recordDispatchE8uint32_t8uint32_t8uint32_t" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records the dispatch function with the provided template parameters or alternatively using the size of the tensor by default.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">x</span></code>: Layout X dispatch value </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">y</span></code>: Layout Y dispatch value </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">z</span></code>: Layout Z dispatch value </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
</div>
</dd></dl>


<h2 id="opbase">OpBase<a class="headerlink" href="#opbase" title="Permalink to this headline">¶</a></h2>
<p>The kp::OpBase provides a top level class for an operation in Kompute, which is the step that is executed on a GPU submission. The Kompute operations can consist of one or more kp::Tensor.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-operations.jpg"><img alt="../_images/kompute-vulkan-architecture-operations.jpg" src="../_images/kompute-vulkan-architecture-operations.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp6OpBaseE">
<span id="_CPPv3N2kp6OpBaseE"></span><span id="_CPPv2N2kp6OpBaseE"></span><span id="kp::OpBase"></span><span class="target" id="classkp_1_1OpBase"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpBase</code><a class="headerlink" href="#_CPPv4N2kp6OpBaseE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base Operation which provides the high level interface that Kompute operations implement in order to perform a set of actions in the GPU.</p>
<p>Operations can perform actions on tensors, and optionally can also own an <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> with respective parameters. kp::Operations with kp::Algorithms would inherit from kp::OpBaseAlgo. </p>
<p>Subclassed by <a class="reference internal" href="#classkp_1_1OpAlgoBase"><span class="std std-ref">kp::OpAlgoBase</span></a>, <a class="reference internal" href="#classkp_1_1OpTensorCopy"><span class="std std-ref">kp::OpTensorCopy</span></a>, <a class="reference internal" href="#classkp_1_1OpTensorCreate"><span class="std std-ref">kp::OpTensorCreate</span></a>, <a class="reference internal" href="#classkp_1_1OpTensorSyncDevice"><span class="std std-ref">kp::OpTensorSyncDevice</span></a>, <a class="reference internal" href="#classkp_1_1OpTensorSyncLocal"><span class="std std-ref">kp::OpTensorSyncLocal</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBase6OpBaseEv">
<span id="_CPPv3N2kp6OpBase6OpBaseEv"></span><span id="_CPPv2N2kp6OpBase6OpBaseEv"></span><span id="kp::OpBase::OpBase"></span><span class="target" id="classkp_1_1OpBase_1ad0b568269057a48cf5c71c5616bba750"></span><code class="sig-name descname">OpBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6OpBase6OpBaseEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base constructor, should not be used unless explicitly intended. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBase6OpBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEEb">
<span id="_CPPv3N2kp6OpBase6OpBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEEb"></span><span id="_CPPv2N2kp6OpBase6OpBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEEb"></span><span id="kp::OpBase::OpBase__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:.std::vector:std::shared_ptr:Tensor::R.b"></span><span class="target" id="classkp_1_1OpBase_1ab84b915d9e0627590c34a1f83dad0a9e"></span><code class="sig-name descname">OpBase</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em>, bool <em>freeTensors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6OpBase6OpBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEEb" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the bare minimum requirements for the operations to be able to create and manage their sub-components.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device used to find device queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device for passing to <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that are to be used in this operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">freeTensors</span></code>: Whether operation manages the memory of the Tensors </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBaseD0Ev">
<span id="_CPPv3N2kp6OpBaseD0Ev"></span><span id="_CPPv2N2kp6OpBaseD0Ev"></span><span id="kp::OpBase::~OpBase"></span><span class="target" id="classkp_1_1OpBase_1aab3aa15a2a7f6482461a1ff9de3b47af"></span><code class="sig-name descname">~OpBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6OpBaseD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor for <a class="reference internal" href="#classkp_1_1OpBase"><span class="std std-ref">OpBase</span></a> class. This <a class="reference internal" href="#classkp_1_1OpBase"><span class="std std-ref">OpBase</span></a> destructor class should always be called to destroy and free owned resources unless it is intended to destroy the resources in the parent class. This can be done by passing the mFreeTensors=false. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBase4initEv">
<span id="_CPPv3N2kp6OpBase4initEv"></span><span id="_CPPv2N2kp6OpBase4initEv"></span><span id="kp::OpBase::init"></span><span class="target" id="classkp_1_1OpBase_1af1fb6bd20031f0a70b5ef881f88de721"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N2kp6OpBase4initEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>The init function is responsible for setting up all the resources and should be called after the Operation has been created. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBase6recordEv">
<span id="_CPPv3N2kp6OpBase6recordEv"></span><span id="_CPPv2N2kp6OpBase6recordEv"></span><span id="kp::OpBase::record"></span><span class="target" id="classkp_1_1OpBase_1a242dbf4582c0b3b1d1a1f2a2207833ef"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N2kp6OpBase6recordEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>The record function is intended to only send a record command or run commands that are expected to record operations that are to be submitted as a batch into the GPU. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBase7preEvalEv">
<span id="_CPPv3N2kp6OpBase7preEvalEv"></span><span id="_CPPv2N2kp6OpBase7preEvalEv"></span><span id="kp::OpBase::preEval"></span><span class="target" id="classkp_1_1OpBase_1a88242bddb815c3775621037046bb504e"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N2kp6OpBase7preEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Pre eval is called before the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> has called eval and submitted the commands to the GPU for processing, and can be used to perform any per-eval setup steps required as the computation iteration begins. It’s worth noting that there are situations where eval can be called multiple times, so the resources that are created should be idempotent in case it’s called multiple times in a row. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpBase8postEvalEv">
<span id="_CPPv3N2kp6OpBase8postEvalEv"></span><span id="_CPPv2N2kp6OpBase8postEvalEv"></span><span id="kp::OpBase::postEval"></span><span class="target" id="classkp_1_1OpBase_1a2c4ca56bd07fa3dbf32e8edb983f50b9"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> = 0<a class="headerlink" href="#_CPPv4N2kp6OpBase8postEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Post eval is called after the <a class="reference internal" href="#classkp_1_1Sequence"><span class="std std-ref">Sequence</span></a> has called eval and submitted the commands to the GPU for processing, and can be used to perform any tear-down steps required as the computation iteration finishes. It’s worth noting that there are situations where eval can be called multiple times, so the resources that are destroyed should not require a re-init unless explicitly provided by the user. </p>
</dd></dl>
</div>
</dd></dl>


<h2 id="opalgobase">OpAlgoBase<a class="headerlink" href="#opalgobase" title="Permalink to this headline">¶</a></h2>
<p>The vk::OpAlgoBase extends the vk::OpBase class, and provides the base for shader-based operations. Besides of consisting of one or more vk::Tensor as per the vk::OpBase, it also contains a unique vk::Algorithm.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-opmult.jpg"><img alt="../_images/kompute-vulkan-architecture-opmult.jpg" src="../_images/kompute-vulkan-architecture-opmult.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp10OpAlgoBaseE">
<span id="_CPPv3N2kp10OpAlgoBaseE"></span><span id="_CPPv2N2kp10OpAlgoBaseE"></span><span id="kp::OpAlgoBase"></span><span class="target" id="classkp_1_1OpAlgoBase"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpAlgoBase</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBaseE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that provides a general abstraction that simplifies the use of algorithm and parameter components which can be used with shaders. By default it enables the user to provide a dynamic number of tensors which are then passed as inputs. </p>
<p>Subclassed by kp::OpAlgoLhsRhsOut, <a class="reference internal" href="#classkp_1_1OpMult"><span class="std std-ref">kp::OpMult</span></a></p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp10OpAlgoBase10OpAlgoBaseEv">
<span id="_CPPv3N2kp10OpAlgoBase10OpAlgoBaseEv"></span><span id="_CPPv2N2kp10OpAlgoBase10OpAlgoBaseEv"></span><span id="kp::OpAlgoBase::OpAlgoBase"></span><span class="target" id="classkp_1_1OpAlgoBase_1a8315949fc5a931b787ccbfe32f5bb118"></span><code class="sig-name descname">OpAlgoBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBase10OpAlgoBaseEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base constructor, should not be used unless explicitly intended. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEE16KomputeWorkgroup">
<span id="_CPPv3N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEE16KomputeWorkgroup"></span><span id="_CPPv2N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEE16KomputeWorkgroup"></span><span id="kp::OpAlgoBase::OpAlgoBase__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:.std::vector:std::shared_ptr:Tensor::R.KomputeWorkgroup"></span><span class="target" id="classkp_1_1OpAlgoBase_1a909a3ad08bd4e4e84c60fa9e9c286b52"></span><code class="sig-name descname">OpAlgoBase</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em>, <a class="reference internal" href="#_CPPv4N2kp10OpAlgoBase16KomputeWorkgroupE" title="kp::OpAlgoBase::KomputeWorkgroup">KomputeWorkgroup</a> <em>komputeWorkgroup</em> = <a class="reference internal" href="#_CPPv4N2kp10OpAlgoBase16KomputeWorkgroupE" title="kp::OpAlgoBase::KomputeWorkgroup">KomputeWorkgroup</a>()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEE16KomputeWorkgroup" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the bare minimum requirements for the operations to be able to create and manage their sub-components.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device used to find device queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device for passing to <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that are to be used in this operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shaderFilePath</span></code>: Optional parameter to specify the shader to load (either in spirv or raw format) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">komputeWorkgroup</span></code>: Optional parameter to specify the layout for processing </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringE16KomputeWorkgroup">
<span id="_CPPv3N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringE16KomputeWorkgroup"></span><span id="_CPPv2N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringE16KomputeWorkgroup"></span><span id="kp::OpAlgoBase::OpAlgoBase__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:.std::vector:std::shared_ptr:Tensor::R.ss.KomputeWorkgroup"></span><span class="target" id="classkp_1_1OpAlgoBase_1a3357a5cfd099bace5b42f5bdbf3d0e57"></span><code class="sig-name descname">OpAlgoBase</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em>, std::string <em>shaderFilePath</em>, <a class="reference internal" href="#_CPPv4N2kp10OpAlgoBase16KomputeWorkgroupE" title="kp::OpAlgoBase::KomputeWorkgroup">KomputeWorkgroup</a> <em>komputeWorkgroup</em> = <a class="reference internal" href="#_CPPv4N2kp10OpAlgoBase16KomputeWorkgroupE" title="kp::OpAlgoBase::KomputeWorkgroup">KomputeWorkgroup</a>()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEENSt6stringE16KomputeWorkgroup" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Constructor that enables a file to be passed to the operation with the contents of the shader. This can be either in raw format or in compiled SPIR-V binary format.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device used to find device queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device for passing to <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that are to be used in this operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shaderFilePath</span></code>: Parameter to specify the shader to load (either in spirv or raw format) </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">komputeWorkgroup</span></code>: Optional parameter to specify the layout for processing </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorIcEE16KomputeWorkgroup">
<span id="_CPPv3N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorIcEE16KomputeWorkgroup"></span><span id="_CPPv2N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorIcEE16KomputeWorkgroup"></span><span id="kp::OpAlgoBase::OpAlgoBase__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:.std::vector:std::shared_ptr:Tensor::R.std::vector:c:CR.KomputeWorkgroup"></span><span class="target" id="classkp_1_1OpAlgoBase_1a0c95e1180bb9a7ac7b60b7116f336f70"></span><code class="sig-name descname">OpAlgoBase</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; &amp;<em>tensors</em>, <em class="property">const</em> std::vector&lt;char&gt; &amp;<em>shaderDataRaw</em>, <a class="reference internal" href="#_CPPv4N2kp10OpAlgoBase16KomputeWorkgroupE" title="kp::OpAlgoBase::KomputeWorkgroup">KomputeWorkgroup</a> <em>komputeWorkgroup</em> = <a class="reference internal" href="#_CPPv4N2kp10OpAlgoBase16KomputeWorkgroupE" title="kp::OpAlgoBase::KomputeWorkgroup">KomputeWorkgroup</a>()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBase10OpAlgoBaseENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEERNSt6vectorINSt10shared_ptrI6TensorEEEERKNSt6vectorIcEE16KomputeWorkgroup" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Constructor that enables raw shader data to be passed to the main operation which can be either in raw shader glsl code or in compiled SPIR-V binary.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device used to find device queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device for passing to <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that are to be used in this operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">shaderDataRaw</span></code>: Optional parameter to specify the shader data either in binary or raw form </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">komputeWorkgroup</span></code>: Optional parameter to specify the layout for processing </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp10OpAlgoBaseD0Ev">
<span id="_CPPv3N2kp10OpAlgoBaseD0Ev"></span><span id="_CPPv2N2kp10OpAlgoBaseD0Ev"></span><span id="kp::OpAlgoBase::~OpAlgoBase"></span><span class="target" id="classkp_1_1OpAlgoBase_1a0dfee08381bcc6d082a2f22940912ab1"></span><code class="sig-name descname">~OpAlgoBase</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBaseD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor, which is in charge of destroying the algorithm components but does not destroy the underlying tensors </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp10OpAlgoBase4initEv">
<span id="_CPPv3N2kp10OpAlgoBase4initEv"></span><span id="_CPPv2N2kp10OpAlgoBase4initEv"></span><span id="kp::OpAlgoBase::init"></span><span class="target" id="classkp_1_1OpAlgoBase_1a3c19a222f489492cf6681c0dcb30225d"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBase4initEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>The init function is responsible for the initialisation of the algorithm component based on the parameters specified, and allows for extensibility on the options provided. Further dependent classes can perform more specific checks such as ensuring tensors provided are initialised, etc. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp10OpAlgoBase6recordEv">
<span id="_CPPv3N2kp10OpAlgoBase6recordEv"></span><span id="_CPPv2N2kp10OpAlgoBase6recordEv"></span><span id="kp::OpAlgoBase::record"></span><span class="target" id="classkp_1_1OpAlgoBase_1a56c250f754b40034116611aff7791703"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBase6recordEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>This records the commands that are to be sent to the GPU. This includes the barriers that ensure the memory has been copied before going in and out of the shader, as well as the dispatch operation that sends the shader processing to the gpu. This function also records the GPU memory copy of the output data for the staging buffer so it can be read by the host. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp10OpAlgoBase7preEvalEv">
<span id="_CPPv3N2kp10OpAlgoBase7preEvalEv"></span><span id="_CPPv2N2kp10OpAlgoBase7preEvalEv"></span><span id="kp::OpAlgoBase::preEval"></span><span class="target" id="classkp_1_1OpAlgoBase_1abcc3e584fe5ceeb392acecea63a1069e"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBase7preEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any preEval commands. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp10OpAlgoBase8postEvalEv">
<span id="_CPPv3N2kp10OpAlgoBase8postEvalEv"></span><span id="_CPPv2N2kp10OpAlgoBase8postEvalEv"></span><span id="kp::OpAlgoBase::postEval"></span><span class="target" id="classkp_1_1OpAlgoBase_1a8fd28e54862f3d0c0b3394514d981175"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBase8postEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Executes after the recorded commands are submitted, and performs a copy of the GPU Device memory into the staging buffer so the output data can be retrieved. </p>
</dd></dl>
</div>
<dl class="cpp struct">
<dt id="_CPPv4N2kp10OpAlgoBase16KomputeWorkgroupE">
<span id="_CPPv3N2kp10OpAlgoBase16KomputeWorkgroupE"></span><span id="_CPPv2N2kp10OpAlgoBase16KomputeWorkgroupE"></span><span id="kp::OpAlgoBase::KomputeWorkgroup"></span><span class="target" id="structkp_1_1OpAlgoBase_1_1KomputeWorkgroup"></span><em class="property">struct </em><code class="sig-name descname">KomputeWorkgroup</code><a class="headerlink" href="#_CPPv4N2kp10OpAlgoBase16KomputeWorkgroupE" title="Permalink to this definition">¶</a><br/></dt>
<dd></dd></dl>
</dd></dl>


<h2 id="opmult">OpMult<a class="headerlink" href="#opmult" title="Permalink to this headline">¶</a></h2>
<p>The kp::OpMult operation is a sample implementation of the kp::OpAlgoBase class. This class shows how it is possible to create a custom vk::OpAlgoBase that can compile as part of the binary. The kp::OpMult operation uses the shader-to-cpp-header-file script to convert the script into cpp header files.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-opmult.jpg"><img alt="../_images/kompute-vulkan-architecture-opmult.jpg" src="../_images/kompute-vulkan-architecture-opmult.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp6OpMultE">
<span id="_CPPv3N2kp6OpMultE"></span><span id="_CPPv2N2kp6OpMultE"></span><span id="kp::OpMult"></span><span class="target" id="classkp_1_1OpMult"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpMult</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp10OpAlgoBaseE" title="kp::OpAlgoBase">OpAlgoBase</a><a class="headerlink" href="#_CPPv4N2kp6OpMultE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that performs multiplication on two tensors and outpus on third tensor. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpMult6OpMultEv">
<span id="_CPPv3N2kp6OpMult6OpMultEv"></span><span id="_CPPv2N2kp6OpMult6OpMultEv"></span><span id="kp::OpMult::OpMult"></span><span class="target" id="classkp_1_1OpMult_1a295ede6f7f1b0b8add558a2dc3e3b838"></span><code class="sig-name descname">OpMult</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6OpMult6OpMultEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Base constructor, should not be used unless explicitly intended. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpMult6OpMultENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE16KomputeWorkgroup">
<span id="_CPPv3N2kp6OpMult6OpMultENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE16KomputeWorkgroup"></span><span id="_CPPv2N2kp6OpMult6OpMultENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE16KomputeWorkgroup"></span><span id="kp::OpMult::OpMult__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:.std::vector:std::shared_ptr:Tensor::.KomputeWorkgroup"></span><span class="target" id="classkp_1_1OpMult_1a9329068fd4de1d6a6e98ceca173fcc52"></span><code class="sig-name descname">OpMult</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em>, KomputeWorkgroup <em>komputeWorkgroup</em> = KomputeWorkgroup()<span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp6OpMult6OpMultENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE16KomputeWorkgroup" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the bare minimum requirements for the operations to be able to create and manage their sub-components.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device used to find device queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device for passing to <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that are to be used in this operation </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">komputeWorkgroup</span></code>: Optional parameter to specify the layout for processing </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp6OpMultD0Ev">
<span id="_CPPv3N2kp6OpMultD0Ev"></span><span id="_CPPv2N2kp6OpMultD0Ev"></span><span id="kp::OpMult::~OpMult"></span><span class="target" id="classkp_1_1OpMult_1a5f6bcf968416f6d434f849dbe510d269"></span><code class="sig-name descname">~OpMult</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp6OpMultD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor, which is in charge of destroying the algorithm components but does not destroy the underlying tensors </p>
</dd></dl>
</div>
</dd></dl>


<h2 id="optensorcreate">OpTensorCreate<a class="headerlink" href="#optensorcreate" title="Permalink to this headline">¶</a></h2>
<p>The kp::OpTensorCreate is a tensor only operations which initialises a kp::Tensor by creating the respective vk::Buffer and vk::Memory, as well as transferring the local data into the GPU.</p>
<a class="reference internal image-reference" href="../_images/kompute-vulkan-architecture-opcreatetensor.jpg"><img alt="../_images/kompute-vulkan-architecture-opcreatetensor.jpg" src="../_images/kompute-vulkan-architecture-opcreatetensor.jpg" style="width: 100%;"/></a>
<dl class="cpp class">
<dt id="_CPPv4N2kp14OpTensorCreateE">
<span id="_CPPv3N2kp14OpTensorCreateE"></span><span id="_CPPv2N2kp14OpTensorCreateE"></span><span id="kp::OpTensorCreate"></span><span class="target" id="classkp_1_1OpTensorCreate"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpTensorCreate</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><a class="headerlink" href="#_CPPv4N2kp14OpTensorCreateE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that creates tensor and manages the memory of the components created </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpTensorCreate14OpTensorCreateENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE">
<span id="_CPPv3N2kp14OpTensorCreate14OpTensorCreateENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="_CPPv2N2kp14OpTensorCreate14OpTensorCreateENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="kp::OpTensorCreate::OpTensorCreate__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:.std::vector:std::shared_ptr:Tensor::"></span><span class="target" id="classkp_1_1OpTensorCreate_1a2675d4ffa3aade69fc2404d7642905c6"></span><code class="sig-name descname">OpTensorCreate</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp14OpTensorCreate14OpTensorCreateENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the bare minimum requirements for the operations to be able to create and manage their sub-components.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device used to find device queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device for passing to <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that will be used to create in operation. </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">freeTensors</span></code>: Whether operation manages the memory of the Tensors </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpTensorCreateD0Ev">
<span id="_CPPv3N2kp14OpTensorCreateD0Ev"></span><span id="_CPPv2N2kp14OpTensorCreateD0Ev"></span><span id="kp::OpTensorCreate::~OpTensorCreate"></span><span class="target" id="classkp_1_1OpTensorCreate_1abfcfc2a3a12e1acafc25cbde1243f7f7"></span><code class="sig-name descname">~OpTensorCreate</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp14OpTensorCreateD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor which in this case expects the parent class to free the tensors </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpTensorCreate4initEv">
<span id="_CPPv3N2kp14OpTensorCreate4initEv"></span><span id="_CPPv2N2kp14OpTensorCreate4initEv"></span><span id="kp::OpTensorCreate::init"></span><span class="target" id="classkp_1_1OpTensorCreate_1a5faf4a58ab30828a64a1175fd5ca28da"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp14OpTensorCreate4initEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>In charge of initialising the primary <a class="reference internal" href="#classkp_1_1Tensor"><span class="std std-ref">Tensor</span></a> as well as the staging tensor as required. It will only initialise a staging tensor if the Primary tensor is of type Device. For staging tensors it performs a mapDataIntoHostMemory which would perform immediately as opposed to on sequence eval/submission. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpTensorCreate6recordEv">
<span id="_CPPv3N2kp14OpTensorCreate6recordEv"></span><span id="_CPPv2N2kp14OpTensorCreate6recordEv"></span><span id="kp::OpTensorCreate::record"></span><span class="target" id="classkp_1_1OpTensorCreate_1a823777887f9b48a76fe94e323885f60f"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp14OpTensorCreate6recordEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Record runs the core actions to create the tensors. For device tensors it records a copyCommand to move the data from the staging tensor to the device tensor. The mapping for staging tensors happens in the init function not in the record function. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpTensorCreate7preEvalEv">
<span id="_CPPv3N2kp14OpTensorCreate7preEvalEv"></span><span id="_CPPv2N2kp14OpTensorCreate7preEvalEv"></span><span id="kp::OpTensorCreate::preEval"></span><span class="target" id="classkp_1_1OpTensorCreate_1ab4d77a85d72981f38dc878dba4646e9f"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp14OpTensorCreate7preEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any preEval commands. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp14OpTensorCreate8postEvalEv">
<span id="_CPPv3N2kp14OpTensorCreate8postEvalEv"></span><span id="_CPPv2N2kp14OpTensorCreate8postEvalEv"></span><span id="kp::OpTensorCreate::postEval"></span><span class="target" id="classkp_1_1OpTensorCreate_1af4eb86a8ecd71b91eee3f0274d9dfeda"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp14OpTensorCreate8postEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Performs a copy back into the main tensor to ensure that the data contained is the one that is now being stored in the GPU. </p>
</dd></dl>
</div>
</dd></dl>


<h2 id="optensorcopy">OpTensorCopy<a class="headerlink" href="#optensorcopy" title="Permalink to this headline">¶</a></h2>
<p>The kp::OpTensorCopy is a tensor only operation that copies the GPU memory buffer data from one kp::Tensor to one or more subsequent tensors.</p>
<dl class="cpp class">
<dt id="_CPPv4N2kp12OpTensorCopyE">
<span id="_CPPv3N2kp12OpTensorCopyE"></span><span id="_CPPv2N2kp12OpTensorCopyE"></span><span id="kp::OpTensorCopy"></span><span class="target" id="classkp_1_1OpTensorCopy"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpTensorCopy</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopyE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that copies the data from the first tensor to the rest of the tensors provided, using a record command for all the vectors. This operation does not own/manage the memory of the tensors passed to it. The operation must only receive tensors of type </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopy12OpTensorCopyENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE">
<span id="_CPPv3N2kp12OpTensorCopy12OpTensorCopyENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="_CPPv2N2kp12OpTensorCopy12OpTensorCopyENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="kp::OpTensorCopy::OpTensorCopy__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:.std::vector:std::shared_ptr:Tensor::"></span><span class="target" id="classkp_1_1OpTensorCopy_1a412de294c41e5f73d6feb5fc7880182b"></span><code class="sig-name descname">OpTensorCopy</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopy12OpTensorCopyENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the core vulkan resources and the tensors that will be used in the operation.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device used to find device queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device for passing to <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that will be used to create in operation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopyD0Ev">
<span id="_CPPv3N2kp12OpTensorCopyD0Ev"></span><span id="_CPPv2N2kp12OpTensorCopyD0Ev"></span><span id="kp::OpTensorCopy::~OpTensorCopy"></span><span class="target" id="classkp_1_1OpTensorCopy_1acfde203e1614298ace93389f5fdb0564"></span><code class="sig-name descname">~OpTensorCopy</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopyD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor. This class does not manage memory so it won’t be expecting the parent to perform a release. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopy4initEv">
<span id="_CPPv3N2kp12OpTensorCopy4initEv"></span><span id="_CPPv2N2kp12OpTensorCopy4initEv"></span><span id="kp::OpTensorCopy::init"></span><span class="target" id="classkp_1_1OpTensorCopy_1a0f2c124b5193e9f6df3485466c1dc136"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopy4initEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Performs basic checks such as ensuring there are at least two tensors provided, that they are initialised and that they are not of type TensorTypes::eStorage. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopy6recordEv">
<span id="_CPPv3N2kp12OpTensorCopy6recordEv"></span><span id="_CPPv2N2kp12OpTensorCopy6recordEv"></span><span id="kp::OpTensorCopy::record"></span><span class="target" id="classkp_1_1OpTensorCopy_1a85aa269cd3ddc507b8ae33f84ff1158b"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopy6recordEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Records the copy commands from the first tensor into all the other tensors provided. Also optionally records a barrier. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopy7preEvalEv">
<span id="_CPPv3N2kp12OpTensorCopy7preEvalEv"></span><span id="_CPPv2N2kp12OpTensorCopy7preEvalEv"></span><span id="kp::OpTensorCopy::preEval"></span><span class="target" id="classkp_1_1OpTensorCopy_1ab405b3c1db34b2cb9b48d36a1101baa6"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopy7preEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any preEval commands. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp12OpTensorCopy8postEvalEv">
<span id="_CPPv3N2kp12OpTensorCopy8postEvalEv"></span><span id="_CPPv2N2kp12OpTensorCopy8postEvalEv"></span><span id="kp::OpTensorCopy::postEval"></span><span class="target" id="classkp_1_1OpTensorCopy_1adb73b3854dcf4ecb7711cd0d9d7af3bf"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp12OpTensorCopy8postEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Copies the local vectors for all the tensors to sync the data with the gpu. </p>
</dd></dl>
</div>
</dd></dl>


<h2 id="optensorsynclocal">OpTensorSyncLocal<a class="headerlink" href="#optensorsynclocal" title="Permalink to this headline">¶</a></h2>
<p>The kp::OpTensorSyncLocal is a tensor only operation that maps the data from the GPU device memory into the local host vector.</p>
<dl class="cpp class">
<dt id="_CPPv4N2kp17OpTensorSyncLocalE">
<span id="_CPPv3N2kp17OpTensorSyncLocalE"></span><span id="_CPPv2N2kp17OpTensorSyncLocalE"></span><span id="kp::OpTensorSyncLocal"></span><span class="target" id="classkp_1_1OpTensorSyncLocal"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpTensorSyncLocal</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocalE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that syncs tensor’s local data by mapping the data from device memory into the local vector. For TensorTypes::eDevice it will use a staging tensor to perform the copy. For TensorTypes::eStaging it will only copy the data and perform a map, which will be executed during the postSubmit (there will be no copy during the sequence eval/submit). This function cannot be carried out for TensorTypes::eStaging. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocal17OpTensorSyncLocalENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE">
<span id="_CPPv3N2kp17OpTensorSyncLocal17OpTensorSyncLocalENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="_CPPv2N2kp17OpTensorSyncLocal17OpTensorSyncLocalENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="kp::OpTensorSyncLocal::OpTensorSyncLocal__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:.std::vector:std::shared_ptr:Tensor::"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1a843ba988f4229454cfe37970120ffbb6"></span><code class="sig-name descname">OpTensorSyncLocal</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocal17OpTensorSyncLocalENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the core vulkan resources and the tensors that will be used in the operation. The tensors provided cannot be of type TensorTypes::eStorage.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device used to find device queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device for passing to <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that will be used to create in operation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocalD0Ev">
<span id="_CPPv3N2kp17OpTensorSyncLocalD0Ev"></span><span id="_CPPv2N2kp17OpTensorSyncLocalD0Ev"></span><span id="kp::OpTensorSyncLocal::~OpTensorSyncLocal"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1abe9a817363d192a190b93cf520449397"></span><code class="sig-name descname">~OpTensorSyncLocal</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocalD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor. This class manages the memory of the staging tensors it owns but these are released in the postSubmit, before it arrives to the destructor. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocal4initEv">
<span id="_CPPv3N2kp17OpTensorSyncLocal4initEv"></span><span id="_CPPv2N2kp17OpTensorSyncLocal4initEv"></span><span id="kp::OpTensorSyncLocal::init"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1a912daf0e890c16937ed4ff7c93a2807c"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocal4initEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Performs basic checks such as ensuring that there is at least one tensor provided, that they are initialized and that they are not of type TensorTpes::eStaging. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocal6recordEv">
<span id="_CPPv3N2kp17OpTensorSyncLocal6recordEv"></span><span id="_CPPv2N2kp17OpTensorSyncLocal6recordEv"></span><span id="kp::OpTensorSyncLocal::record"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1a3ff2889d246eec5b7fa45705716a1408"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocal6recordEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>For device tensors, it records the copy command into the staging tensor from the device tensor. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocal7preEvalEv">
<span id="_CPPv3N2kp17OpTensorSyncLocal7preEvalEv"></span><span id="_CPPv2N2kp17OpTensorSyncLocal7preEvalEv"></span><span id="kp::OpTensorSyncLocal::preEval"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1af10063e16f74008b714642a22ac3b6f3"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocal7preEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any preEval commands. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp17OpTensorSyncLocal8postEvalEv">
<span id="_CPPv3N2kp17OpTensorSyncLocal8postEvalEv"></span><span id="_CPPv2N2kp17OpTensorSyncLocal8postEvalEv"></span><span id="kp::OpTensorSyncLocal::postEval"></span><span class="target" id="classkp_1_1OpTensorSyncLocal_1a8a79f05b1403f4d83c480f7f77279693"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp17OpTensorSyncLocal8postEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>For host tensors it performs the map command from the host memory into local memory. </p>
</dd></dl>
</div>
</dd></dl>


<h2 id="optensorsyncdevice">OpTensorSyncDevice<a class="headerlink" href="#optensorsyncdevice" title="Permalink to this headline">¶</a></h2>
<p>The kp::OpTensorSyncDevice is a tensor only operation that maps the data from the local host vector into the GPU device memory.</p>
<dl class="cpp class">
<dt id="_CPPv4N2kp18OpTensorSyncDeviceE">
<span id="_CPPv3N2kp18OpTensorSyncDeviceE"></span><span id="_CPPv2N2kp18OpTensorSyncDeviceE"></span><span id="kp::OpTensorSyncDevice"></span><span class="target" id="classkp_1_1OpTensorSyncDevice"></span><em class="property">class </em><code class="sig-prename descclassname">kp<code class="sig-prename descclassname">::</code></code><code class="sig-name descname">OpTensorSyncDevice</code> : <em class="property">public</em> kp::<a class="reference internal" href="#_CPPv4N2kp6OpBaseE" title="kp::OpBase">OpBase</a><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDeviceE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Operation that syncs tensor’s device by mapping local data into the device memory. For TensorTypes::eDevice it will use a staging tensor to perform the copy. For TensorTypes::eStaging it will only copy the data and perform a map, which will be executed during the record (as opposed to during the sequence eval/submit). This function cannot be carried out for TensorTypes::eStaging. </p>
<div class="breathe-sectiondef docutils container">
<p class="breathe-sectiondef-title rubric">Public Functions</p>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDevice18OpTensorSyncDeviceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE">
<span id="_CPPv3N2kp18OpTensorSyncDevice18OpTensorSyncDeviceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="_CPPv2N2kp18OpTensorSyncDevice18OpTensorSyncDeviceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE"></span><span id="kp::OpTensorSyncDevice::OpTensorSyncDevice__std::shared_ptr:vk::PhysicalDevice:.std::shared_ptr:vk::Device:.std::shared_ptr:vk::CommandBuffer:.std::vector:std::shared_ptr:Tensor::"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1aedd10f74c3d10b5e182501c9b4c24516"></span><code class="sig-name descname">OpTensorSyncDevice</code><span class="sig-paren">(</span>std::shared_ptr&lt;vk::PhysicalDevice&gt; <em>physicalDevice</em>, std::shared_ptr&lt;vk::Device&gt; <em>device</em>, std::shared_ptr&lt;vk::CommandBuffer&gt; <em>commandBuffer</em>, std::vector&lt;std::shared_ptr&lt;<a class="reference internal" href="#_CPPv4N2kp6TensorE" title="kp::Tensor">Tensor</a>&gt;&gt; <em>tensors</em><span class="sig-paren">)</span><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDevice18OpTensorSyncDeviceENSt10shared_ptrIN2vk14PhysicalDeviceEEENSt10shared_ptrIN2vk6DeviceEEENSt10shared_ptrIN2vk13CommandBufferEEENSt6vectorINSt10shared_ptrI6TensorEEEE" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default constructor with parameters that provides the core vulkan resources and the tensors that will be used in the operation. The tensos provided cannot be of type TensorTypes::eStorage.</p>
<p><dl class="simple">
<dt><strong>Parameters</strong></dt><dd><ul class="breatheparameterlist simple">
<li><p><code class="docutils literal notranslate"><span class="pre">physicalDevice</span></code>: Vulkan physical device used to find device queues </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">device</span></code>: Vulkan logical device for passing to <a class="reference internal" href="#classkp_1_1Algorithm"><span class="std std-ref">Algorithm</span></a> </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">commandBuffer</span></code>: Vulkan Command Buffer to record commands into </p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">tensors</span></code>: Tensors that will be used to create in operation. </p></li>
</ul>
</dd>
</dl>
</p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDeviceD0Ev">
<span id="_CPPv3N2kp18OpTensorSyncDeviceD0Ev"></span><span id="_CPPv2N2kp18OpTensorSyncDeviceD0Ev"></span><span id="kp::OpTensorSyncDevice::~OpTensorSyncDevice"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1a990df433f503d85828392e4d50db77c1"></span><code class="sig-name descname">~OpTensorSyncDevice</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDeviceD0Ev" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Default destructor. This class does not manage memory so it won’t be expecting the parent to perform a release. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDevice4initEv">
<span id="_CPPv3N2kp18OpTensorSyncDevice4initEv"></span><span id="_CPPv2N2kp18OpTensorSyncDevice4initEv"></span><span id="kp::OpTensorSyncDevice::init"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1ae53cab8c44f3c68d71a591f7c17029be"></span>void <code class="sig-name descname">init</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDevice4initEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Performs basic checks such as ensuring that there is at least one tensor provided, that they are initialized and that they are not of type TensorTpes::eStaging. For staging tensors in host memory, the map is performed during the init function. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDevice6recordEv">
<span id="_CPPv3N2kp18OpTensorSyncDevice6recordEv"></span><span id="_CPPv2N2kp18OpTensorSyncDevice6recordEv"></span><span id="kp::OpTensorSyncDevice::record"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1a84ffa11a9fe3a43e594b8e10c085583d"></span>void <code class="sig-name descname">record</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDevice6recordEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>For device tensors, it records the copy command to the device tensor from the temporary staging tensor. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDevice7preEvalEv">
<span id="_CPPv3N2kp18OpTensorSyncDevice7preEvalEv"></span><span id="_CPPv2N2kp18OpTensorSyncDevice7preEvalEv"></span><span id="kp::OpTensorSyncDevice::preEval"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1a0f5a3ab84329a32aeb23bbd99cec9467"></span>void <code class="sig-name descname">preEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDevice7preEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any preEval commands. </p>
</dd></dl>
<dl class="cpp function">
<dt id="_CPPv4N2kp18OpTensorSyncDevice8postEvalEv">
<span id="_CPPv3N2kp18OpTensorSyncDevice8postEvalEv"></span><span id="_CPPv2N2kp18OpTensorSyncDevice8postEvalEv"></span><span id="kp::OpTensorSyncDevice::postEval"></span><span class="target" id="classkp_1_1OpTensorSyncDevice_1a2124d84d6c3d4f00e8a8adcf3d6e018f"></span>void <code class="sig-name descname">postEval</code><span class="sig-paren">(</span><span class="sig-paren">)</span> <em class="property">override</em><a class="headerlink" href="#_CPPv4N2kp18OpTensorSyncDevice8postEvalEv" title="Permalink to this definition">¶</a><br/></dt>
<dd><p>Does not perform any postEval commands. </p>
</dd></dl>
</div>
</dd></dl>




          </article>
        </div>
      </div>
    </main>
  </div>
  <footer class="md-footer">
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
          
            <a href="custom-operations.html" title="Extending Kompute with Custom C++ Operations"
               class="md-flex md-footer-nav__link md-footer-nav__link--prev"
               rel="prev">
              <div class="md-flex__cell md-flex__cell--shrink">
                <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
              </div>
              <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
                <span class="md-flex__ellipsis">
                  <span
                      class="md-footer-nav__direction"> Previous </span> Extending Kompute with Custom C++ Operations </span>
              </div>
            </a>
          
          
            <a href="python-package.html" title="Python Package Overview"
               class="md-flex md-footer-nav__link md-footer-nav__link--next"
               rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title"><span
                class="md-flex__ellipsis"> <span
                class="md-footer-nav__direction"> Next </span> Python Package Overview </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink"><i
                class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          
        </a>
        
      </nav>
    </div>
    <div class="md-footer-meta md-typeset">
      <div class="md-footer-meta__inner md-grid">
        <div class="md-footer-copyright">
          <div class="md-footer-copyright__highlight">
              &#169; Copyright 2020, The Institute for Ethical AI &amp; Machine Learning.
              
          </div>
            Created using
            <a href="http://www.sphinx-doc.org/">Sphinx</a> 3.2.1.
             and
            <a href="https://github.com/bashtage/sphinx-material/">Material for
              Sphinx</a>
        </div>
      </div>
    </div>
  </footer>
  <script src="../_static/javascripts/application.js"></script>
  <script>app.initialize({version: "1.0.4", url: {base: ".."}})</script>
  </body>
</html>