<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Kompute: kp::Tensor Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Kompute
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>kp</b></li><li class="navelem"><a class="el" href="classkp_1_1Tensor.html">Tensor</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classkp_1_1Tensor-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">kp::Tensor Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="Tensor_8hpp_source.html">Tensor.hpp</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a1b2af1c0e8dc0f154e11780e7103beb4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> { <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a> = 0, 
<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a746241fcf54388332f43a13dd4a82f0a">TensorTypes::eHost</a> = 1, 
<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4ae1a7e733531f08074becd467959f0521">TensorTypes::eStorage</a> = 2
 }</td></tr>
<tr class="separator:a1b2af1c0e8dc0f154e11780e7103beb4"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a41f9d2cfc069fd4f57781c8f0de3a135"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a41f9d2cfc069fd4f57781c8f0de3a135">Tensor</a> (std::shared_ptr&lt; vk::PhysicalDevice &gt; physicalDevice, std::shared_ptr&lt; vk::Device &gt; device, const std::vector&lt; float &gt; &amp;<a class="el" href="classkp_1_1Tensor.html#a858f9a010a112983244cdf16ea0e5308">data</a>, const <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> &amp;<a class="el" href="classkp_1_1Tensor.html#a59452f1c62fd738536bb0a6cbf8d896b">tensorType</a>=<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a>)</td></tr>
<tr class="separator:a41f9d2cfc069fd4f57781c8f0de3a135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a38e886e69103a956b994790f320a254e"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a38e886e69103a956b994790f320a254e">~Tensor</a> ()</td></tr>
<tr class="separator:a38e886e69103a956b994790f320a254e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1eb83d6d5c896eccd017f8074b2d9f38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a1eb83d6d5c896eccd017f8074b2d9f38">rebuild</a> (const std::vector&lt; float &gt; &amp;<a class="el" href="classkp_1_1Tensor.html#a858f9a010a112983244cdf16ea0e5308">data</a>, <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> <a class="el" href="classkp_1_1Tensor.html#a59452f1c62fd738536bb0a6cbf8d896b">tensorType</a>=<a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a>)</td></tr>
<tr class="separator:a1eb83d6d5c896eccd017f8074b2d9f38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cdbcb7abaad8f3e3a392741ea5ad275"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a5cdbcb7abaad8f3e3a392741ea5ad275">destroy</a> ()</td></tr>
<tr class="separator:a5cdbcb7abaad8f3e3a392741ea5ad275"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2ae7f0b57fd8e57570ab63962a97f36"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#af2ae7f0b57fd8e57570ab63962a97f36">isInit</a> ()</td></tr>
<tr class="separator:af2ae7f0b57fd8e57570ab63962a97f36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a858f9a010a112983244cdf16ea0e5308"><td class="memItemLeft" align="right" valign="top">std::vector&lt; float &gt; &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a858f9a010a112983244cdf16ea0e5308">data</a> ()</td></tr>
<tr class="separator:a858f9a010a112983244cdf16ea0e5308"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64ff1ca98d5380cc3916e13b20f7a509"><td class="memItemLeft" align="right" valign="top">float &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a64ff1ca98d5380cc3916e13b20f7a509">operator[]</a> (int index)</td></tr>
<tr class="separator:a64ff1ca98d5380cc3916e13b20f7a509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fb937df6cc482c1f37c74d8fab0f9a9"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a1fb937df6cc482c1f37c74d8fab0f9a9">size</a> ()</td></tr>
<tr class="separator:a1fb937df6cc482c1f37c74d8fab0f9a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59452f1c62fd738536bb0a6cbf8d896b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a59452f1c62fd738536bb0a6cbf8d896b">tensorType</a> ()</td></tr>
<tr class="separator:a59452f1c62fd738536bb0a6cbf8d896b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3618a3e5a86cfaad31820f9910525424"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a3618a3e5a86cfaad31820f9910525424">setData</a> (const std::vector&lt; float &gt; &amp;<a class="el" href="classkp_1_1Tensor.html#a858f9a010a112983244cdf16ea0e5308">data</a>)</td></tr>
<tr class="separator:a3618a3e5a86cfaad31820f9910525424"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391daa58dae36aa1d9b539e85937478f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a391daa58dae36aa1d9b539e85937478f">recordCopyFrom</a> (const vk::CommandBuffer &amp;commandBuffer, std::shared_ptr&lt; <a class="el" href="classkp_1_1Tensor.html">Tensor</a> &gt; copyFromTensor, bool createBarrier)</td></tr>
<tr class="separator:a391daa58dae36aa1d9b539e85937478f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5e4c626cc66e24d0055a8468174d97"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#aff5e4c626cc66e24d0055a8468174d97">recordCopyFromStagingToDevice</a> (const vk::CommandBuffer &amp;commandBuffer, bool createBarrier)</td></tr>
<tr class="separator:aff5e4c626cc66e24d0055a8468174d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9779708781431ce758cc9044a02c4582"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a9779708781431ce758cc9044a02c4582">recordCopyFromDeviceToStaging</a> (const vk::CommandBuffer &amp;commandBuffer, bool createBarrier)</td></tr>
<tr class="separator:a9779708781431ce758cc9044a02c4582"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecfaadf43600fb9e742aac6e35883851"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#aecfaadf43600fb9e742aac6e35883851">recordBufferMemoryBarrier</a> (const vk::CommandBuffer &amp;commandBuffer, vk::AccessFlagBits srcAccessMask, vk::AccessFlagBits dstAccessMask, vk::PipelineStageFlagBits srcStageMask, vk::PipelineStageFlagBits dstStageMask)</td></tr>
<tr class="separator:aecfaadf43600fb9e742aac6e35883851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a805e6050a935763488116e071c0ce461"><td class="memItemLeft" align="right" valign="top">vk::DescriptorBufferInfo&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#a805e6050a935763488116e071c0ce461">constructDescriptorBufferInfo</a> ()</td></tr>
<tr class="separator:a805e6050a935763488116e071c0ce461"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8e16f48058f17d55d313727c9ceaa46"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#ae8e16f48058f17d55d313727c9ceaa46">mapDataFromHostMemory</a> ()</td></tr>
<tr class="separator:ae8e16f48058f17d55d313727c9ceaa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeeeb1b7d8ed4681565f17e44c98fb704"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classkp_1_1Tensor.html#aeeeb1b7d8ed4681565f17e44c98fb704">mapDataIntoHostMemory</a> ()</td></tr>
<tr class="separator:aeeeb1b7d8ed4681565f17e44c98fb704"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Structured data used in GPU operations.</p>
<p>Tensors are the base building block in Kompute to perform operations across GPUs. Each tensor would have a respective Vulkan memory and buffer, which would be used to store their respective data. The tensors can be used for GPU data storage or transfer. </p>
</div><h2 class="groupheader">Member Enumeration Documentation</h2>
<a id="a1b2af1c0e8dc0f154e11780e7103beb4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b2af1c0e8dc0f154e11780e7103beb4">&#9670;&nbsp;</a></span>TensorTypes</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">kp::Tensor::TensorTypes</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Type for tensors created: Device allows memory to be transferred from staging buffers. Staging are host memory visible. Storage are device visible but are not set up to transfer or receive data (only for shader storage). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f"></a>eDevice&#160;</td><td class="fielddoc"><p>Type is device memory, source and destination. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b2af1c0e8dc0f154e11780e7103beb4a746241fcf54388332f43a13dd4a82f0a"></a>eHost&#160;</td><td class="fielddoc"><p>Type is host memory, source and destination. </p>
</td></tr>
<tr><td class="fieldname"><a id="a1b2af1c0e8dc0f154e11780e7103beb4ae1a7e733531f08074becd467959f0521"></a>eStorage&#160;</td><td class="fielddoc"><p>Type is Device memory (only) </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a41f9d2cfc069fd4f57781c8f0de3a135"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41f9d2cfc069fd4f57781c8f0de3a135">&#9670;&nbsp;</a></span>Tensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kp::Tensor::Tensor </td>
          <td>(</td>
          <td class="paramtype">std::shared_ptr&lt; vk::PhysicalDevice &gt;&#160;</td>
          <td class="paramname"><em>physicalDevice</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; vk::Device &gt;&#160;</td>
          <td class="paramname"><em>device</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> &amp;&#160;</td>
          <td class="paramname"><em>tensorType</em> = <code><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructor with data provided which would be used to create the respective vulkan buffer and memory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">physicalDevice</td><td>The physical device to use to fetch properties </td></tr>
    <tr><td class="paramname">device</td><td>The device to use to create the buffer and memory from </td></tr>
    <tr><td class="paramname">data</td><td>Non-zero-sized vector of data that will be used by the tensor </td></tr>
    <tr><td class="paramname">tensorTypes</td><td>Type for the tensor which is of type TensorTypes </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a38e886e69103a956b994790f320a254e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a38e886e69103a956b994790f320a254e">&#9670;&nbsp;</a></span>~Tensor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">kp::Tensor::~Tensor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destructor which is in charge of freeing vulkan resources unless they have been provided externally. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a805e6050a935763488116e071c0ce461"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a805e6050a935763488116e071c0ce461">&#9670;&nbsp;</a></span>constructDescriptorBufferInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">vk::DescriptorBufferInfo kp::Tensor::constructDescriptorBufferInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Constructs a vulkan descriptor buffer info which can be used to specify and reference the underlying buffer component of the tensor without exposing it.</p>
<dl class="section return"><dt>Returns</dt><dd>Descriptor buffer info with own buffer </dd></dl>

</div>
</div>
<a id="a858f9a010a112983244cdf16ea0e5308"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a858f9a010a112983244cdf16ea0e5308">&#9670;&nbsp;</a></span>data()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt;float&gt;&amp; kp::Tensor::data </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the vector of data currently contained by the <a class="el" href="classkp_1_1Tensor.html">Tensor</a>. It is important to ensure that there is no out-of-sync data with the GPU memory.</p>
<dl class="section return"><dt>Returns</dt><dd>Reference to vector of elements representing the data in the tensor. </dd></dl>

</div>
</div>
<a id="a5cdbcb7abaad8f3e3a392741ea5ad275"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5cdbcb7abaad8f3e3a392741ea5ad275">&#9670;&nbsp;</a></span>destroy()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::destroy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Destroys and frees the GPU resources which include the buffer and memory. </p>

</div>
</div>
<a id="af2ae7f0b57fd8e57570ab63962a97f36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2ae7f0b57fd8e57570ab63962a97f36">&#9670;&nbsp;</a></span>isInit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool kp::Tensor::isInit </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check whether tensor is initialized based on the created gpu resources.</p>
<dl class="section return"><dt>Returns</dt><dd>Boolean stating whether tensor is initialized </dd></dl>

</div>
</div>
<a id="ae8e16f48058f17d55d313727c9ceaa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8e16f48058f17d55d313727c9ceaa46">&#9670;&nbsp;</a></span>mapDataFromHostMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::mapDataFromHostMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps data from the Host Visible GPU memory into the data vector. It requires the <a class="el" href="classkp_1_1Tensor.html">Tensor</a> to be of staging type for it to work. </p>

</div>
</div>
<a id="aeeeb1b7d8ed4681565f17e44c98fb704"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeeeb1b7d8ed4681565f17e44c98fb704">&#9670;&nbsp;</a></span>mapDataIntoHostMemory()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::mapDataIntoHostMemory </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Maps data from the data vector into the Host Visible GPU memory. It requires the tensor to be of staging type for it to work. </p>

</div>
</div>
<a id="a64ff1ca98d5380cc3916e13b20f7a509"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64ff1ca98d5380cc3916e13b20f7a509">&#9670;&nbsp;</a></span>operator[]()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">float&amp; kp::Tensor::operator[] </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Overrides the subscript operator to expose the underlying data's subscript operator which in this case would be its underlying vector's.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">i</td><td>The index where the element will be returned from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the element in the position requested. </dd></dl>

</div>
</div>
<a id="a1eb83d6d5c896eccd017f8074b2d9f38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1eb83d6d5c896eccd017f8074b2d9f38">&#9670;&nbsp;</a></span>rebuild()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::rebuild </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a>&#160;</td>
          <td class="paramname"><em>tensorType</em> = <code><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4a4380df4c549f2a42e0f127869f41bd4f">TensorTypes::eDevice</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Function to trigger reinitialisation of the tensor buffer and memory with new data as well as new potential device type.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>Vector of data to use to initialise vector from </td></tr>
    <tr><td class="paramname">tensorType</td><td>The type to use for the tensor </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aecfaadf43600fb9e742aac6e35883851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecfaadf43600fb9e742aac6e35883851">&#9670;&nbsp;</a></span>recordBufferMemoryBarrier()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordBufferMemoryBarrier </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::AccessFlagBits&#160;</td>
          <td class="paramname"><em>srcAccessMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::AccessFlagBits&#160;</td>
          <td class="paramname"><em>dstAccessMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::PipelineStageFlagBits&#160;</td>
          <td class="paramname"><em>srcStageMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">vk::PipelineStageFlagBits&#160;</td>
          <td class="paramname"><em>dstStageMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records the buffer memory barrier into the command buffer which ensures that relevant data transfers are carried out correctly.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
    <tr><td class="paramname">srcAccessMask</td><td>Access flags for source access mask </td></tr>
    <tr><td class="paramname">dstAccessMask</td><td>Access flags for destination access mask </td></tr>
    <tr><td class="paramname">scrStageMask</td><td>Pipeline stage flags for source stage mask </td></tr>
    <tr><td class="paramname">dstStageMask</td><td>Pipeline stage flags for destination stage mask </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a391daa58dae36aa1d9b539e85937478f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391daa58dae36aa1d9b539e85937478f">&#9670;&nbsp;</a></span>recordCopyFrom()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordCopyFrom </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::shared_ptr&lt; <a class="el" href="classkp_1_1Tensor.html">Tensor</a> &gt;&#160;</td>
          <td class="paramname"><em>copyFromTensor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createBarrier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records a copy from the memory of the tensor provided to the current thensor. This is intended to pass memory into a processing, to perform a staging buffer transfer, or to gather output (between others).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
    <tr><td class="paramname">copyFromTensor</td><td><a class="el" href="classkp_1_1Tensor.html">Tensor</a> to copy the data from </td></tr>
    <tr><td class="paramname">createBarrier</td><td>Whether to create a barrier that ensures the data is copied before further operations. Default is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9779708781431ce758cc9044a02c4582"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9779708781431ce758cc9044a02c4582">&#9670;&nbsp;</a></span>recordCopyFromDeviceToStaging()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordCopyFromDeviceToStaging </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createBarrier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records a copy from the internal device memory to the staging memory using an optional barrier to wait for the operation. This function would only be relevant for kp::Tensors of type eDevice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
    <tr><td class="paramname">createBarrier</td><td>Whether to create a barrier that ensures the data is copied before further operations. Default is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aff5e4c626cc66e24d0055a8468174d97"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5e4c626cc66e24d0055a8468174d97">&#9670;&nbsp;</a></span>recordCopyFromStagingToDevice()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::recordCopyFromStagingToDevice </td>
          <td>(</td>
          <td class="paramtype">const vk::CommandBuffer &amp;&#160;</td>
          <td class="paramname"><em>commandBuffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>createBarrier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Records a copy from the internal staging memory to the device memory using an optional barrier to wait for the operation. This function would only be relevant for kp::Tensors of type eDevice.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">commandBuffer</td><td>Vulkan Command Buffer to record the commands into </td></tr>
    <tr><td class="paramname">createBarrier</td><td>Whether to create a barrier that ensures the data is copied before further operations. Default is true. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a3618a3e5a86cfaad31820f9910525424"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3618a3e5a86cfaad31820f9910525424">&#9670;&nbsp;</a></span>setData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void kp::Tensor::setData </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; float &gt; &amp;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sets / resets the vector data of the tensor. This function does not perform any copies into GPU memory and is only performed on the host. </p>

</div>
</div>
<a id="a1fb937df6cc482c1f37c74d8fab0f9a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fb937df6cc482c1f37c74d8fab0f9a9">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t kp::Tensor::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the size/magnitude of the <a class="el" href="classkp_1_1Tensor.html">Tensor</a>, which will be the total number of elements across all dimensions</p>
<dl class="section return"><dt>Returns</dt><dd>Unsigned integer representing the total number of elements </dd></dl>

</div>
</div>
<a id="a59452f1c62fd738536bb0a6cbf8d896b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59452f1c62fd738536bb0a6cbf8d896b">&#9670;&nbsp;</a></span>tensorType()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classkp_1_1Tensor.html#a1b2af1c0e8dc0f154e11780e7103beb4">TensorTypes</a> kp::Tensor::tensorType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Retrieve the tensor type of the <a class="el" href="classkp_1_1Tensor.html">Tensor</a></p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classkp_1_1Tensor.html">Tensor</a> type of tensor </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/c/Users/axsau/Programming/vulkan/vulkan-compute/src/include/kompute/<a class="el" href="Tensor_8hpp_source.html">Tensor.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.13
</small></address>
</body>
</html>
